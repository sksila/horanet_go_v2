import logging

from odoo import models, fields, api, tools
from odoo.addons.mail.models.mail_template import format_date

USAGE_STATE = [('floating', 'Floating'), ('open', 'Open'), ('sealed', 'Sealed')]

_logger = logging.getLogger(__name__)


class HoranetUsage(models.Model):
    # region Private attributes
    _name = 'horanet.usage'

    # endregion

    # region Default methods
    # endregion

    # region Fields declaration
    state = fields.Selection(string="State", selection=USAGE_STATE, readonly=True)
    quantity = fields.Float(string="Quantity", required=True)
    is_processed = fields.Boolean(string="Is processed")
    package_line_id = fields.Many2one(string="Package", comodel_name='horanet.package.line')
    activity_id = fields.Many2one(string="Activity", comodel_name='horanet.activity', required=True)
    usage_date = fields.Datetime(string="Date usage", default=fields.Datetime.now)

    sale_order_line_id = fields.Many2one(string="Sale order line", comodel_name='sale.order.line', readonly=True)
    sale_order_id = fields.Many2one(string="Sale order", comodel_name='sale.order', readonly=True)
    invoice_line_ids = fields.Many2many(string="Invoice lines", comodel_name='account.invoice.line', readonly=True)
    invoice_ids = fields.Many2many(string="Invoices", comodel_name='account.invoice')
    unit_id = fields.Many2one(string="Unit", related="activity_id.product_uom_id", readonly=True)
    is_invoiced = fields.Boolean(string="Is invoiced", readonly=True, compute='compute_is_invoiced', store=True)
    is_delivered = fields.Boolean(string="Is delivered", readonly=True)

    origin_engine_result_id = fields.Many2one(
        string="Origine exploitation engine result",
        comodel_name='exploitation.engine.result',
        ondelete='restrict')
    origin_operation_id = fields.Many2one(
        string="Origin operation", comodel_name='horanet.operation',
        related='origin_engine_result_id.trigger_operation_id')
    origin_execution_log = fields.Text(
        string="Execution log",
        related='origin_engine_result_id.execution_log')

    # endregion

    # region Fields method
    @api.onchange('package_line_id')
    def _onchange_subscription_id(self):
        return {
            'domain': {
                'activity_id': [('id', 'in', self.package_line_id.activity_ids.ids)],
            }}

    @api.depends('invoice_ids', 'invoice_line_ids')
    def compute_is_invoiced(self):
        """Compute the invoice status of the usage.

        A usage is invoiced if his invoice is different than draft or cancel.
        """
        for rec in self:
            is_invoiced = rec.invoice_ids.filtered(lambda r: r.state not in ['draft', 'cancel'])
            if is_invoiced:
                rec.is_invoiced = True
    # endregion

    # region Constrains and Onchange
    # endregion

    # region CRUD (overrides)
    @api.multi
    def unlink(self):
        """Update the sale order line for each usage if we delete them."""
        for rec in self:
            if rec.sale_order_line_id:
                if rec.package_line_id.is_salable:
                    rec.sale_order_line_id.product_uom_qty = rec.sale_order_line_id.product_uom_qty - rec.quantity
                    if rec.is_delivered:
                        rec.sale_order_line_id.qty_delivered = rec.sale_order_line_id.qty_delivered - rec.quantity
                        rec.package_line_id.balance_total = rec.package_line_id.balance_total - rec.quantity
                else:
                    rec.sale_order_line_id.product_uom_qty = 0
                    if rec.is_delivered:
                        rec.sale_order_line_id.qty_delivered = 0
                        rec.package_line_id.balance_total = 0

        return super(HoranetUsage, self).unlink()
    # endregion

    # region Actions
    # endregion

    # region Model methods
    @api.multi
    def to_string(self):
        result = []
        for usage in self:
            # activity_str = u"activity {activity_name}".format(activity_name=unicode(usage.activity_id.name))
            contract_srt = "not linked to a contract line"
            if usage.package_line_id:
                contract_srt = "on contract line {contract_name},{subscription_id}".format(
                    contract_name=str(usage.package_line_id.name),
                    subscription_id=str(usage.package_line_id.id),
                )

            operation_to_string = "quantity {quantity}, activity {activity_name} {contract_srt}".format(
                quantity=usage.quantity or '0',
                activity_name=str(usage.activity_id.name),
                contract_srt=contract_srt, )

            result.append((usage.id or None, operation_to_string))
        return result

    def bill_usages(self):
        """
        Set for each usage the corresponding sale order and/or sale order line.

        :return: list of sale order  and sale order lines.
        """
        for usage in self:
            package_line = usage.package_line_id

            # On cherche la subscription line correspondant à l'usage
            subscription_line = self.env['horanet.subscription.line'].get_subscription_line(usage=usage)

            if not subscription_line:
                # In case the invoice cycle isn't created yet, for a usage in the futur
                # for example, we don't need to create the sale order
                _logger.warning('The usage %s cannot be put on any sale order '
                                'because there is no invoice cycle corresponding '
                                'to the date %s' % (usage.id, usage.usage_date))
                continue
            if len(subscription_line) != 1:
                _logger.info('WARNING Contrat id %i: several or no periods found for a usage' % (self.id))
                continue

            # Nom unique du SO line
            so_line_name = subscription_line.get_so_name_subscription_line(package_line, usage)

            # On va chercher le sale order
            so = subscription_line.get_or_create_sale_order()
            # usage.package_line_id.sale_order_id = so.id
            usage.sale_order_id = so.id

            # Si il n'y a pas de produit ou que le package n'est pas facturable
            if not usage.activity_id.product_id or not package_line.is_salable:
                # Si l'usage est relié à un forfait, alors on le met dans la même ligne de SO
                if usage.package_line_id.use_product:
                    name = subscription_line.get_so_name_subscription_line(package_line)
                    sale_order_line_model = self.env['sale.order.line']
                    order_line = sale_order_line_model.search([
                        ('order_id', '=', usage.sale_order_id.id),
                        ('name', '=', name),
                        ('id', 'in', usage.package_line_id.package_order_line_ids.ids)
                    ])
                    usage.sale_order_line_id = order_line.id
                    continue
                # Si il n'y a rien, alors on s'arrête là
                else:
                    continue

            # On va créer le sale order line
            sol = subscription_line.get_or_create_sale_order_line(usage, so_line_name)

            usage.sale_order_line_id = sol.id

    @api.multi
    @api.returns('product.pricelist.item')
    def get_pricelist_item(self, partner):
        """Return pricelist item that corresponds to current date, partner and product.

        :param partner: the partner of the sale order
        """
        self.ensure_one()

        partner_categories = partner.mapped('subscription_category_ids')
        pricelist_items = self.activity_id.product_id.mapped('item_ids')

        usage_date = format_date(self.env, self.usage_date, tools.DEFAULT_SERVER_DATE_FORMAT)

        pricelist_items = pricelist_items \
            .filtered(lambda p: p.partner_category_ids & partner_categories) \
            .filtered(lambda p: p.date_start and p.date_start <= usage_date or not p.date_start) \
            .filtered(lambda p: p.date_end and p.date_end >= usage_date or not p.date_end)

        if len(pricelist_items) > 1:
            # We return the pricelist item that will be the cheapest
            return pricelist_items.sorted('fixed_price')[0]
        else:
            return pricelist_items
    # endregion

    pass
