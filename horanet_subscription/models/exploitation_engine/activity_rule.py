import logging

from odoo import models, fields, api, _
from odoo.osv import expression

_logger = logging.getLogger(__name__)
RULE_STATES = [('active', 'Active'), ('disabled', 'Disabled'), ('inactive', 'Inactive')]


class HoranetActivityRule(models.Model):
    """This model represent an activity rule, it is bind to an activity rule version.

    This model is meant to represent the active version of a rule, each medication of a record of this model will
    trigger the creation of a new rule version and a 'rebinding' to this new version.

    This class contain all methods relative to the rule search and execution plan/log
    """

    # region Private attributes
    _name = 'activity.rule'
    _inherits = {'activity.rule.version': 'rule_version_id'}
    # endregion

    # region Default methods
    # endregion

    # region Fields declaration
    rule_version_id = fields.Many2one(
        string="Rule version",
        comodel_name='activity.rule.version',
        required=True,
        ondelete='restrict',
        delegate=True,
        auto_join=True,
    )
    state = fields.Selection(
        string="State",
        selection=RULE_STATES,
        compute='_compute_state',
        search='_search_state',
        store=False,
        help="""'active': this rule can be executed\n
        'inactive': this rule period doesn't match the current date\n
        'disabled': this rule is flagged to be ignored for execution"""
    )

    # endregion

    # region Fields method
    @api.depends('beginning_date', 'ending_date', 'enabled')
    def _compute_state(self):
        """Compute the rule state.

        'active': this rule can be executed
        'inactive': this rule period doesn't match the current date
        'enabled': this rule is flagged to be ignored for execution
        :return:
        """
        for rec in self:
            state = 'active'
            if not rec.enabled:
                state = 'disabled'
            elif rec.beginning_date and rec.beginning_date > fields.Date.today():
                state = 'inactive'
            elif rec.ending_date and rec.ending_date < fields.Date.today():
                state = 'inactive'
            rec.state = state

    @api.model
    def _search_state(self, operator, value, search_date=None):
        """Allow to perform a fast search on state field (used to find rule that can be executed).

        :param operator: opérateur de recherche
        :param value: valeur recherchée ('active' ou 'disabled' ou 'inactive')
        :return: Retourne un domain de recherche correspondant à la recherche sur le champ calculé state
        """
        search_date = search_date or fields.Date.today()
        # positive search domain
        search_date_valid = ['&',
                             '|', ('beginning_date', '=', False), ('beginning_date', '<=', search_date),
                             '|', ('ending_date', '=', False), ('ending_date', '>=', search_date)]
        search_enabled = [('enabled', '=', True)]
        search_domain = []
        if value == 'active':
            search_domain = expression.AND([search_enabled, search_date_valid])
        elif value == 'disabled':
            search_domain = [expression.NOT_OPERATOR] + search_enabled
        elif value == 'inactive':
            search_domain = expression.AND([search_enabled, [expression.NOT_OPERATOR] + search_date_valid])

        # en cas de recherche inverse, inverser le domain (exemple '!=' de False)
        if search_domain and operator in expression.NEGATIVE_TERM_OPERATORS:
            search_domain = [expression.NOT_OPERATOR] + search_domain

        return expression.normalize_domain(search_domain)

    # endregion

    # region Constrains and Onchange
    # endregion

    # region CRUD (overrides)
    @api.multi
    def write(self, vals):
        """Overwrite write method used to generate rule.version record when altering a rule record.

        :param vals: dict vals: fields to update and the value to set on them
        :raise ValidateError: if user tries to modify a rule version on any other field than 'active'
        :return: True if no problems found
        """
        if not self:
            return True
        self._check_concurrency()
        self.check_access_rights('write')

        # Si on ne change que le field rule_version_id, on quitte l'overwrite, pour éviter un problème de récursion car
        # la suite du code va modifier le champ rule_version_id (et donc appeler la méthode write)
        if all([k in ['rule_version_id'] for k in list(vals.keys())]):
            return super(HoranetActivityRule, self).write(vals)

        for rec in self:
            default_vals = dict(vals)
            default_vals.update({'active': False,
                                 'version': rec.version + 1})
            new_rule_version = rec.rule_version_id.copy(default_vals)
            rec.rule_version_id.active = False
            rec.rule_version_id = new_rule_version
            rec.rule_version_id.active = True

        return True

    @api.multi
    def name_get(self):
        res = []
        for rule in self:
            name = rule.name + ' (' + rule.code + ') v' + str(rule.version)
            res.append((rule.id, name))
        return res

    # endregion

    # region Actions
    @api.multi
    def action_deactivate(self):
        for rec in self:
            if rec.enabled:
                rec.enabled = False

    @api.multi
    def action_activate(self):
        for rec in self:
            if not rec.enabled:
                rec.enabled = True

    @api.multi
    def action_show_diagram(self):
        """Open the custom diagram view of sector activities and rule activities."""
        self.ensure_one()
        diagram = self.env['wizard.activity.diagram'].create({})
        result = diagram.get_diagram_action_value()
        result.update({'name': _("Rules Diagram")})
        return result

    # endregion

    # region Model methods
    @api.model
    def resolve_rule_execution_plan(self, activities, action=None, sector=False, search_date=None):
        """Get an ordered list of rule matching the sector/activity.

        This method resolve the "stack" of rule to be executed for an activity by sector

        :param activities: (recordset) The activity or activities used to select matching rules
        :param action: A record 'horanet.action' used to filter the rules
        :param sector: optional sector used to start the search of rule in the stack of sector, if None, only global
                        rules will be searched
        :param search_date: optional date used to filter active rules (default = today)
        :returns: A list of tuple like : (order<int>,rule<record>)
        """
        # TODO : add filter on actions
        if not isinstance(activities, models.Model):
            raise TypeError("The attribute 'activity' must be a recordset")
        if sector and not isinstance(sector, models.Model):
            raise TypeError("The attribute 'sector' must be a record")
        if action and not isinstance(action, models.Model):
            raise TypeError("The attribute 'action' must be a record")
        if search_date and not isinstance(search_date, str):
            raise TypeError("The argument 'search_date' must be an ORM date")
        search_date = search_date or fields.Date.today()

        ordered_rules = self.env['activity.rule']
        current_sector = sector

        # appel du search pour factoriser le code de recherche de date
        domain_search_active = self._search_state('=', 'active', search_date)
        while current_sector:
            matching_rules_domain = expression.AND([
                domain_search_active,
                [('activity_ids', 'in', activities.ids), ('activity_sector_id', '=', current_sector.id)]
            ])
            rules = self.sudo().search(matching_rules_domain, order='priority asc')
            if rules:
                ordered_rules = ordered_rules + rules
            # test pour remonter au secteur parent
            # (et vérification du paradoxe de Fry au cas ou un secteur serait son propre parent)
            if current_sector.parent_id and current_sector.parent_id != current_sector:
                current_sector = current_sector.parent_id
            else:
                break

        # get global rules
        global_rules = self.sudo().search(
            expression.AND([
                domain_search_active,
                [('activity_ids', 'in', activities.ids), ('activity_sector_id', '=', False)]]),
            order='priority asc')

        if global_rules:
            ordered_rules = ordered_rules + global_rules

        return ordered_rules

    @api.multi
    def rule_dummy(self, rule_code):
        """Create a new record of activity.rule with new activity.rule.version containing the new rule code."""
        # necessary to conserve the custom rule_code, even if the rule call the linked rule_version
        rule_version_values = self.rule_version_id.read()[0]
        rule_version_values.update({'rule_code': rule_code})
        # pop to force the computation of field embedded_rule_code (store = True)
        rule_version_values.pop('embedded_rule_code', False)
        tmp_rule_version = self.rule_version_id.new(rule_version_values)

        rule_values = self.read()[0]
        rule_values.update({'rule_code': tmp_rule_version.rule_code,
                            'embedded_rule_code': tmp_rule_version.embedded_rule_code,
                            'rule_version_id': tmp_rule_version})
        return self.new(rule_values)

    # endregion

    pass
