from datetime import datetime

from odoo.addons.mail.models.mail_template import format_tz

from odoo import models, fields, api, exceptions, _
from odoo.osv import expression

QUERY_STATE = [('null', 'Empty'), ('error', 'Error'), ('done', 'Done')]


class DeviceQuery(models.Model):
    # region Private attributes
    _name = 'device.query'
    _order = 'create_date desc'

    # endregion

    # region Default methods
    # endregion

    # region Fields declaration
    state = fields.Selection(string="State", selection=QUERY_STATE, default='null',
                             compute='_compute_state',
                             store=True)
    display_name = fields.Char(string="Name", compute='compute_display_name')
    action_id = fields.Many2one(string="Action", comodel_name='horanet.action', required=True)
    tag_id = fields.Many2one(string="Tag", comodel_name='partner.contact.identification.tag', required=False)

    partner_id = fields.Many2one(
        string="Partner",
        comodel_name='res.partner',
        store=True,
    )
    time = fields.Datetime(string="Time", required=True, default=fields.Datetime.now)

    device_id = fields.Many2one(string="Device", comodel_name='horanet.device', required=True)
    check_point_id = fields.Many2one(string="Check point", comodel_name='device.check.point')
    infrastructure_id = fields.Many2one(
        string='Infrastructure',
        comodel_name='horanet.infrastructure',
        store=True
    )
    resulting_engine_result_id = fields.Many2one(
        string="Exploitation engine result",
        comodel_name='exploitation.engine.result')
    resulting_operation_ids = fields.One2many(
        string="Resulting operations", comodel_name='horanet.operation',
        related='resulting_engine_result_id.operation_ids')
    resulting_response_id = fields.One2many(
        string="Resulting response", comodel_name='device.response',
        related='resulting_engine_result_id.response_id')
    resulting_execution_log = fields.Text(
        string="Execution log",
        related='resulting_engine_result_id.execution_log')

    resulting_response = fields.Char(string="Response", compute='_compute_response', store=False)
    resulting_message = fields.Char(string="Message", compute='_compute_message', store=False)

    query_partner_id = fields.Many2one(
        string="Resolved partner",
        comodel_name='res.partner',
        compute='_compute_query_partner_id',
        search='_search_query_partner_id',
        readonly=True,
        store=False,
    )

    # endregion

    # region Fields method

    @api.depends('tag_id', 'partner_id', 'time')
    def _compute_query_partner_id(self):
        u"""Recherche des partner liée aux queries.

        Le partenaire lié à la query est déterminé en fonction de la date de la query ainsi que de
        l'objet référencé par la query (référence direct au partner).
        """
        queries_with_partner = self.filtered('partner_id')
        queries_without_partner = self - queries_with_partner

        for query_with_partner in queries_with_partner:
            query_with_partner.operation_partner_id = query_with_partner.partner_id

        # Pour fortement gagner en performance, l'on recherche les partner liées aux tag en python.
        # Cela évite de faire une requête SQL par opération, car il fait recherche l'assignation qui
        # correspond au moment de réalisation du fait.
        if len(queries_without_partner) > 1:

            sorted_queries = queries_without_partner.sorted('time')
            # recherche des assignations et des partners liée aux tags des queries
            partner_by_tag = queries_without_partner.mapped('tag_id').get_partner_linked_to_multiple_tag(
                start_date=sorted_queries[0].time,
                end_date=sorted_queries[-1].time)

            # partner_by_tag est de la forme : {tag_rec: [(date_start, date_end, partner_rec]}
            for query in queries_without_partner:
                query.query_partner_id = next(
                    (a[2] for a in partner_by_tag[query.tag_id] if
                     a[0] <= query.time and (not a[1] or a[1] >= query.time)),
                    None)

        elif queries_without_partner and queries_without_partner.tag_id:
            queries_without_partner.query_partner_id = \
                queries_without_partner.tag_id.get_partner_linked_to_tag(
                    search_date_utc=queries_without_partner.time)

    def _search_query_partner_id(self, operator, value):
        """Recherche les query d'un partner.

        Si la query est liée à un partner on retrouve ce partner et si elle est liée à un badge qui est lui même
        lié à un forfait, on retrouve le partner du forfait.

        :param operator: the search operator
        :param value: string for a search by name, or int or list(<int>) for a search by id
        :return: A search domain
        """
        if not isinstance(value, int) and not isinstance(value, str) and not isinstance(value, list) \
                or isinstance(value, bool):
            raise TypeError(
                "Search partner on tags: Expected integer or list of integer or string, found {bad_type}".format(
                    bad_type=str(type(value)))
            )

        if isinstance(value, str):
            value = self.env['res.partner'].with_context(prefetch_fields=False).search([('name', 'ilike', value)]).ids
            # On limite la taille de la recherche à 10 partners afin de traiter les doublons et ne pas surcharger odoo.
            if len(value) > 10:
                raise exceptions.UserError(_("Search terms are too large. Please be more specific."))
            else:
                value = list(value)
        if isinstance(value, int):
            value = [value]

        domain = []
        partner_package = self.env['horanet.package'].search([
            ('recipient_id', 'in', value),
        ])
        partner_assignation = self.env['partner.contact.identification.assignation'].search([
            '|',
            ('partner_id', 'in', value),
            ('package_id', 'in', partner_package.ids),
        ])

        for assignation in partner_assignation:
            # on explicite tag_id != False car tag_id est un many2one non obligatoire, donc il peut avoir une valeur
            # null. Or si on ne l'explicite pas, lors d'une recherche négative odoo ne prendra pas en compte ceux ayant,
            # une valeur null.
            assignation_domain = [('tag_id', '!=', False),
                                  ('tag_id', '=', assignation.tag_id.id),
                                  ('time', '>=', assignation.start_date)]

            if assignation.end_date:
                assignation_domain += [('time', '<', assignation.end_date)]
            domain = expression.OR([domain, expression.normalize_domain(assignation_domain)])

        # On explicite partner_id != False pour la même raison que précédemment
        domain = expression.OR([domain, ['&', ('partner_id', '!=', False), ('partner_id', 'in', value)]])

        if operator in expression.NEGATIVE_TERM_OPERATORS:
            domain = [expression.NOT_OPERATOR] + expression.normalize_domain(domain)

        return expression.normalize_domain(domain)

    @api.multi
    @api.depends('action_id')
    def compute_display_name(self):
        for query in self:
            query_date = format_tz(self.env, query.create_date or fields.Datetime.now())
            query.display_name = _("{action} - id:{id} at:{time}").format(
                action=str(query.action_id and query.action_id.name or ''),
                id=str('no id' if isinstance(query.id, models.NewId) else query.id),
                time=query_date)

    @api.depends('resulting_engine_result_id')
    def _compute_response(self):
        for query in self:
            related_response = query.resulting_engine_result_id and query.resulting_engine_result_id.response_id
            if related_response:
                query.resulting_response = _("Yes") if related_response.response else _("No")
            else:
                query.resulting_response = _("Undefined")

    @api.depends('resulting_engine_result_id')
    def _compute_message(self):
        for query in self:
            related_response = query.resulting_engine_result_id and query.resulting_engine_result_id.response_id
            if related_response:
                query.resulting_message = related_response.message
            else:
                query.resulting_message = ''

    @api.depends('resulting_engine_result_id', 'resulting_engine_result_id.state')
    def _compute_state(self):
        for query in self:
            if not query.resulting_engine_result_id:
                query.state = 'null'
            else:
                query.state = query.resulting_engine_result_id.state

    # endregion

    # region Constrains and Onchange
    # endregion

    # region CRUD (overrides)
    # endregion

    # region Actions
    @api.multi
    def action_open_wizard_sandbox(self):
        """Appel du wizard d'éxécution sandbox sur la query courante."""
        self.ensure_one()

        wizard_view = self.env.ref('horanet_subscription.wizard_activity_rule_sandbox_form')
        wizard_rec = self.env['activity.rule.wizard.sandbox'].create({
            'input_mode': 'query',
            'query_time': self.create_date,
            'action_id': self.action_id.id,
            'partner_id': self.partner_id.id,
            'device_id': self.device_id.id,
            'tag_id': self.tag_id.id,
            'check_point_id': self.check_point_id.id,
        })
        return {
            'context': self.env.context,
            'type': 'ir.actions.act_window',

            'res_model': 'activity.rule.wizard.sandbox',
            'src_model': 'horanet.operation',
            'res_id': wizard_rec.id,

            'view_id': wizard_view.id,
            'view_mode': 'form',
            'view_type': 'form',
            'target': 'new',
            'name': 'Operation Sandbox redirection',
        }

    # endregion

    # region Model methods
    @api.multi
    def check_validity(self):
        if not self.device_id:
            raise exceptions.ValidationError("A query must have a linked device")
        if not self.action_id:
            raise exceptions.ValidationError("A query must have a linked action")

    def get_query_linked_packages(self, force_time=False):
        """Permet de retrouver les forfaits correspondant au paramétrage d'une query."""
        self.ensure_one()
        search_time = force_time or self.time or datetime.now()
        packages = self.env['horanet.package']
        log = ''
        if self.partner_id:
            packages = packages.search([('recipient_id', '=', self.partner_id.id)])
            log += "\n\tResolve packages using Partner {partner_hyperlink}".format(
                partner_hyperlink=(
                    '<a href=\"/web#id={model_id}&view_type=form&model=res.partner\">''{text}</a>').format(
                    model_id=str(self.partner_id.id),
                    text=self.partner_id.name + ' - ' + str(self.partner_id.id)))
        elif self.tag_id:
            tag_linked_partner = self.tag_id.get_tag_partner(search_date_utc=search_time)
            tag_hyperlink = ('<a href=\"/web#id={model_id}'
                             '&view_type=form&model=partner.contact.identification.tag\">'
                             '{text}</a>').format(
                model_id=str(self.tag_id.id),
                text=self.tag_id.number)
            partner_hyperlink = ''
            if tag_linked_partner:
                partner_hyperlink = ('<a href=\"/web#id={model_id}'
                                     '&view_type=form&model=res.partner\">'
                                     '{text}</a>').format(
                    model_id=str(tag_linked_partner.id),
                    text=tag_linked_partner.name + ' - ' + str(tag_linked_partner.id))

            log += "\n\tResolve packages using Tag {tag_hyperlink} {partner_link}".format(
                tag_hyperlink=tag_hyperlink,
                partner_link="(no partner linked with this tag)" if not tag_linked_partner else
                "(linked to partner {partner_hyperlink})".format(partner_hyperlink=partner_hyperlink))

            packages = self.tag_id.get_tag_linked_package(given_date=search_time)

        return packages, log

    # endregion

    pass
