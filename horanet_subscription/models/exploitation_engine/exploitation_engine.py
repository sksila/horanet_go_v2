import json
import logging
import time
from datetime import datetime

from odoo import exceptions
from odoo import models, api, fields

try:
    from odoo.addons.horanet_go.tools import utils as hgo_utils
except ImportError:
    from horanet_go.tools import utils as hgo_utils

TRIGGER_TYPE_QUERY = 'query'
TRIGGER_TYPE_OPERATION = 'operation'
EXECUTION_EMPTY = 'rule_response_empty'
EXECUTION_ERROR = 'rule_response_error'
EXECUTION_FINAL = 'rule_response_final'
EXECUTION_OK = 'rule_response_ok'
EXECUTION_RESPONSE_NO = 'rule_response_no'
EXECUTION_RESPONSE_NOMESSAGE = 'rule_response_nomessage'

_logger = logging.getLogger(__name__)


class ExecutionEngine(models.AbstractModel):
    """Gestion du moteur d'exploitation (droits et usages).

    Contient les mécanismes de déclenchement et de calcul du moteur d'exploitation, le déclenchement
    du moteur se fait selon trois mécanismes :
    - Cron
    - WebServices
    - Wizard (sandbox simulation)
    """

    # region Private attributes
    _name = 'exploitation.engine'
    _description = 'Memory record management'
    # endregion

    # region Default methods
    # endregion

    # region Fields declaration
    trigger_query = fields.Many2one(string="Query", comodel_name='device.query')
    trigger_operation = fields.Many2one(string="Query", comodel_name='horanet.operation')

    execution_log = fields.Text(string="Execution log", readonly=True)
    execution_date = fields.Datetime(string="Execution datetime")

    # endregion

    # region Fields method
    # endregion

    # region Constrains and Onchange
    # endregion

    # region CRUD (overrides)
    @api.model
    def new(self, values=None):
        """Override to add new polymorphe parameter 'trigger' in initialisation.

        Surcharge du Create pour y ajouter le paramètre trigger qui représente aussi bien un record
        du modèle device.query que horanet.operation (les deux modèle pouvant déclencher
        le calcul du moteur d'exploitation)
        Objectif : permettre la création de exploitation.engine avec un trigger polymorphe
        """
        values = values or {}
        if 'trigger' in values:
            if values['trigger'] and isinstance(values['trigger'], models.Model):
                if values['trigger']._name in ['device.query', 'horanet.operation']:
                    if values['trigger']._name == 'device.query':
                        values.update({'trigger_query': values['trigger']})
                    else:
                        values.update({'trigger_operation': values['trigger']})
                else:
                    raise Exception("Argument 'trigger' should be a device.query or horanet.operation record")
        return super(ExecutionEngine, self).new(values)

    # endregion

    # region Actions
    # endregion

    # region Model methods
    def get_trigger(self):
        """Get the trigger associated with this engine run.

        :return: Return the trigger if it exists and it's type ('query' or 'operation')
            in a tuple (trigger_record, string type)
        """
        if self.trigger_operation and self.trigger_query:
            raise exceptions.ValidationError("Engine can't be called with multiple triggers")
        elif self.trigger_query:
            return self.trigger_query, TRIGGER_TYPE_QUERY
        elif self.trigger_operation:
            return self.trigger_operation, TRIGGER_TYPE_OPERATION
        else:
            return False, False

    def ensure_trigger_validity(self):
        """Verify if the record has a trigger and if it's required parameters are set.

        :return: Exception if the trigger is not fit for the computation
        """
        result = True
        trigger, trigger_type = self.get_trigger()

        if not trigger:
            raise AttributeError("The attribute 'trigger' is required")
        if trigger_type == TRIGGER_TYPE_QUERY:
            result = self._check_trigger_query_validty(trigger)
        else:
            result = self._check_trigger_operation_validty(trigger)

        return result

    def _check_trigger_operation_validty(self, trigger):
        """check."""
        trigger.check_validity()
        return True

    def _check_trigger_query_validty(self, trigger):
        """check."""
        trigger.check_validity()
        return True

    @api.multi  # noqa: C901 - Complexité à 17
    def compute(self, simulation=True, custom_rule=False, force_time=False, raise_exception=False):
        """Entry point of all exploitation engine computation.

        This method must be called on a record with a trigger set (device.query record OR horanet.operation record)

        :param simulation: Optional. If True, the computation will not save the resulting objects (memory object)
        :param custom_rule: Optional. 'activity.rule' record containing the code to execute
        :param force_time: Optional. If set, this time will override the trigger time
        :param raise_exception: Optional. If True, the method will not create an exploitation.engine.result
         in case of exception, and will break
        :return: a record exploitation.engine.result, not saved in database if the argument simulation is set
        """
        engine_result = None
        trigger = None
        try:
            self.ensure_one()
            execution_log = ''
            self.env.context = hgo_utils.clear_context_default_value(self.env.context)
            start_time = time.time()

            self.ensure_trigger_validity()
            trigger, trigger_type = self.get_trigger()

            # 1 - Verify input parameters
            if force_time and isinstance(force_time, str):
                force_time = fields.Datetime.from_string(force_time)
            elif force_time and not isinstance(force_time, datetime):
                raise AttributeError("The argument 'force_time' must be a datetime object")
            if not force_time:
                force_time = fields.Datetime.from_string(trigger.time)

            # 2 - Resolve activity and packages
            activity, packages_ids, package_log = self._resolve_trigger_activity(force_time=force_time)
            execution_log += package_log

            if activity:
                packages_ids = packages_ids.filtered(lambda a: activity in a.activity_ids)

            # 3 - resolve execution plan if activity found
            exec_plan = False
            if activity and len(activity) == 1:
                if custom_rule:
                    exec_plan = [custom_rule]
                    execution_log += self.prettify_rule_execution_plan(exec_plan, forced=True)
                else:
                    if trigger_type == TRIGGER_TYPE_QUERY:
                        sector_rec = trigger.check_point_id.input_activity_sector_id
                    else:
                        sector_rec = trigger.activity_sector_id or trigger.check_point_id.input_activity_sector_id
                    rule_model = self.env['activity.rule'].sudo()
                    exec_plan = rule_model.resolve_rule_execution_plan(activity, sector=sector_rec)
                    execution_log += self.prettify_rule_execution_plan(exec_plan, sector=sector_rec,
                                                                       activity=activity)

            # 4 - Execute rules (until one break or gave a final response)
            engine_result = None
            list_execution_results = []
            execution_number = 0
            result_execution_log = ''
            if exec_plan and activity and len(activity) == 1:
                exec_time = time.time()

                exec_plan_log = ''
                for rule in exec_plan:
                    execution_number += 1
                    exec_plan_log += "\n\t{execution_number} → Rule {rule_code} execution :".format(
                        rule_code=rule.code,
                        execution_number=execution_number)
                    instance_rule_execution, rule_execution_status, rule_execution_log = self.execute_rule_with_log(
                        rule, activity, trigger, packages_ids, force_time=force_time)
                    exec_plan_log += rule_execution_log
                    # Hack pour ne pas perdre les référence de new_object sur un new_object
                    instance_rule_execution.trigger_id = trigger

                    if rule_execution_status == EXECUTION_ERROR:
                        engine_result = instance_rule_execution.create_new_result()
                        engine_result.state = 'error'
                        result_execution_log += ("\n\t<warn>The rule {rule_name} ({rule_code})"
                                                 " gave an error</warn>").format(
                            rule_name=str(rule.name),
                            rule_code=str(rule.code))
                        break
                    elif rule_execution_status == EXECUTION_FINAL:
                        engine_result = instance_rule_execution.create_new_result()
                        result_execution_log += ("\n\tThe rule {rule_name} ({rule_code})"
                                                 " output a final response").format(
                            rule_name=str(rule.name),
                            rule_code=str(rule.code))
                        engine_result.state = 'done'
                        break
                    else:
                        list_execution_results.append((rule_execution_status, instance_rule_execution, rule))

                execution_log += "\n<b>Rule execution</b> (time: {exec_time:0.3f}s):".format(
                    exec_time=round(time.time() - exec_time, 3)) + exec_plan_log

            # 5 - Response determination:
            if execution_number:
                execution_log += "\n\n<b>Execution result</b>:"
                rule_to_use = None
                # Après l'éxécution des règles, si il n'y à pas de résultat forcé, dépiler la liste des résultats
                if not engine_result:
                    execution_instance_to_use = None
                    negative_execution_results = [e for e in list_execution_results if e[0] == EXECUTION_RESPONSE_NO]
                    # Si il existe une réponse négative, prendre la première
                    if any(negative_execution_results):
                        execution_instance_to_use = negative_execution_results[0][1]
                        rule_to_use = negative_execution_results[0][2]
                    # Si il n'existe plusieurs des réponses positive, prendre la première avec message
                    else:
                        positive_execution_result = [e for e in list_execution_results if e[0] == EXECUTION_OK]
                        if positive_execution_result:
                            execution_instance_to_use = positive_execution_result[0][1]
                            rule_to_use = positive_execution_result[0][2]
                        else:
                            good_result_with_no_message = [e for e in list_execution_results if
                                                           e[0] == EXECUTION_RESPONSE_NOMESSAGE]
                            if good_result_with_no_message:
                                execution_instance_to_use = good_result_with_no_message[0][1]
                                rule_to_use = good_result_with_no_message[0][2]

                    # Création du résultat du moteur d'exploitation
                    if execution_instance_to_use:
                        engine_result = execution_instance_to_use.create_new_result()
                        engine_result.state = 'done'
                        if rule_to_use:
                            result_execution_log += ("\n\tThe rule {rule_name} ({rule_code})"
                                                     " is the significant rule").format(
                                rule_name=str(rule_to_use.name),
                                rule_code=str(rule_to_use.code))
                    else:
                        result_execution_log += "\n\tNo rule output could be used to respond"

                execution_log += result_execution_log
            end_log = "\n\nTotal runtime: {exec_time:0.3f}s".format(exec_time=round(time.time() - start_time, 3))
            # display_date = fields.Datetime.convert_to_display_name(force_time or datetime.now())
            end_log += "\nTime reference UTC {force_time}".format(
                force_time=force_time or datetime.now())

            execution_log = self._format_log(execution_log + end_log)

            if not engine_result:
                engine_result = self.env['exploitation.engine.result'].new({'trigger': trigger})
            engine_result.execution_log = execution_log
        except Exception as e:
            if raise_exception:
                raise
            else:
                if not engine_result:
                    if not trigger:
                        trigger, trigger_type = self.get_trigger()
                    engine_result = self.env['exploitation.engine.result'].new({'trigger': trigger, 'state': 'null'})
                exception_log = '\n\n<error>' + str(repr(e)) + '</error>'
                engine_result.execution_log = str(engine_result.execution_log) + self._format_log(exception_log)
                engine_result.state = 'error'

        if not simulation:
            engine_result = engine_result.save()

        return engine_result

    @api.multi
    def _resolve_trigger_activity(self, force_time):
        """Determine the correct activity to use for the computation.

        The trigger (QUERY or OPERATION) can provide an activity, either directly (ex: operation.activity_id)
        or indirectly via the checkpoint or sector.
        The priority is : Activity > Sector > Checkpoint

        The trigger activities are then compared to the available activities (packages) to find ONE activity

        :param force_time: The fixed time use to perform the search of active packages
        :return: a tuple of (activities, packages)
        """
        self.ensure_one()

        trigger, trigger_type = self.get_trigger()
        activity = self.env['horanet.activity']
        log = "<b>Activity resolution ({trigger_type}):</b>".format(trigger_type=str(trigger_type))
        error, packages, activities = self._get_packages_and_activities(trigger, force_time)
        log += error

        # 2 - resolution of TRIGGER activities (ordre de priorité : activity -> activity_sector -> checkpoint)
        trigger_activities = self.env['horanet.activity']
        operation_activity = None
        sector_activities = None

        if trigger_type == TRIGGER_TYPE_OPERATION:
            operation_activity = trigger.activity_id or None
            sector_activities = trigger.activity_sector_id and trigger.activity_sector_id.activity_ids or None

        checkpoint_activities = trigger.check_point_id and trigger.check_point_id.activity_ids or None

        if operation_activity:
            trigger_activities = operation_activity
            log += "\n\tOperation activity set to : {activities_reference}".format(
                activities_reference=str(operation_activity.reference))
            if activities and operation_activity not in activities:
                log += "\n\t\t▶ <warning>Warning: operation activity not in tag activities</warning>"
            if sector_activities and operation_activity not in sector_activities:
                log += "\n\t\t▶ <warning>Warning: operation activity not in sector activities</warning>"
            if checkpoint_activities and operation_activity not in checkpoint_activities:
                log += "\n\t\t▶ <warning>Warning: operation activity not in check-point activities</warning>"
        elif sector_activities:
            trigger_activities = sector_activities
            log += "\n\tSector induced activities : {activities_reference}".format(
                activities_reference=', '.join([act.reference for act in sector_activities]))
        elif checkpoint_activities:
            trigger_activities = checkpoint_activities
            log += "\n\tCheck-point induced activities : {activities_reference}".format(
                activities_reference=', '.join([act.reference for act in checkpoint_activities]))
        else:
            log += "\n\tNo sector activities found"

        # 3 - Résolution de l'activité (intersection entre activités disponibles et autorisés)
        if operation_activity:
            activity = operation_activity
        elif activities and trigger_activities:
            activity = activities & trigger_activities
        else:
            activity = activities or trigger_activities

        if not activity:
            log += "\n\tResult : Impossible to find activity"
        elif len(activity) > 1:
            log += ("\n\tResult : <error>Error,"
                    " multiple activities found : {activities_reference}</error>").format(
                activities_reference=', '.join([act.reference for act in activity]))
        else:
            log += "\n\tResult : activity found: {activity_name}, ({activities_reference})".format(
                activities_reference=('<a href=\"/web#id={model_id}'
                                      '&view_type=form&model=horanet.activity\">'
                                      '{text}</a>').format(model_id=str(activity.id),
                                                           text=str(
                                                               activity.name + ' - ' + activity.reference)),
                activity_name=str(activity.name))

        return activity, packages, log

    @api.multi
    def _get_packages_and_activities(self, trigger, force_time=False):
        self.ensure_one()

        search_time = force_time or trigger.time or datetime.now()

        # 1 - resolution of TRIGGER TAG activities
        packages = self.env['horanet.package']
        activities = self.env['horanet.activity']
        log = ''
        if trigger._name == 'horanet.operation':
            packages, log = trigger.get_operation_linked_packages(force_time=force_time)
        else:
            packages, log = trigger.get_query_linked_packages(force_time=force_time)

        if not packages:
            log += "\n\tNo activities found (no packages found)"
        else:
            active_package_lines = packages.get_active_line(search_date_utc=search_time)

            if not active_package_lines:
                log += "\n\tNo activities found (only inactives packages found)"
            else:
                activities = active_package_lines.mapped('activity_ids')
                if not activities:
                    log += "\n\tNo activities found (no active packages line found with linked activities)"
                else:
                    log += "\n\t{origin} activities : {activities_reference}".format(
                        origin="Tag induced" if trigger.tag_id else "Partner induced",
                        activities_reference=', '.join([act.reference for act in activities]))

        return log, packages, activities

    @staticmethod
    def _format_log(log):
        log = log.replace('\n', '<br>').replace('\t', '&emsp;')
        log = log.replace('<error>', '<span class=\"bg-danger\">').replace('</error>', '</span>')
        log = log.replace('<warning>', '<span class=\"bg-warning\">').replace('</warning>', '</span>')
        log = log.replace('<info>', '<span class=\"bg-info\">').replace('</info>', '</span>')
        return log

    @staticmethod
    def prettify_rule_execution_plan(rule_list, activity=None, sector=None, forced=False):
        if forced:
            result = "\n\n<b>Execution plan:</b>"
            result += "\n\tForced -> Custom '{rule_name}' ({rule_code}) with priority {priority}\n".format(
                rule_code=rule_list[0].code,
                rule_name=rule_list[0].name,
                priority=str(rule_list[0].priority))
        else:
            result = "\n\n<b>Execution plan"
            if activity:
                result += " for activity (" + str(activity.reference) + ")"
                if sector:
                    result += " and"
            if sector:
                result += " for sector (" + str(sector.code) + ")"
            result += ":</b>\n"

            if not rule_list:
                result += "\t<warning> - No rules to execute - </warning>"
                return result

            sequence = 0
            space_txt = '\t'
            for rule in rule_list:
                sequence += 1
                sector_text = None
                if rule.activity_sector_id:
                    sector_text = "in sector {sector_name}".format(
                        sector_name=str(rule.activity_sector_id.display_name))
                else:
                    sector_text = "no sector (global rule)"
                result += space_txt * sequence
                result += ("{sequence} → rule '{rule_name}' (code:{rule_code}, version:{rule_version})"
                           " {sector_text} with priority {priority}\n").format(
                    sector_text=str(sector_text),
                    rule_code=('<a href=\"/web#id={model_id}'
                               '&view_type=form&model=activity.rule\">'
                               '{text}</a>').format(model_id=str(rule.id), text=str(rule.code)),
                    rule_version=('<a href=\"/web#id={model_id}'
                                  '&view_type=form&model=activity.rule.version\">'
                                  '{text}</a>').format(model_id=str(rule.rule_version_id.id), text=str(rule.version)),
                    rule_name=str(rule.name),
                    priority=str(rule.priority),
                    sequence=str(sequence)
                )
        return ExecutionEngine._format_log(result)

    @api.multi
    def execute_rule_with_log(self, rule, activity, trigger, package_ids, force_time=False):
        """Execute une règle dans un context, génère un résultat un status et un log.

        :param rule: The activity.rule object executed
        :param activity: the orm activity
        :param trigger: The trigger (query or operation)
        :param package_ids: list des packages disponibles dans le context de la règle
        :param force_time: Optional, use to force the time in the execution context
        :return: (instance d'éxécution <activity.rule.execution>, status <enum>, log <str>)
        """
        if not trigger:
            raise AttributeError("The attribute 'trigger' is required")
        if not isinstance(trigger, models.Model):
            raise TypeError("The attribute 'trigger' must be a record")
        if trigger._name not in ['device.query', 'horanet.operation']:
            raise TypeError("The attribute 'trigger' must be an operation or a query")

        instance_rule_execution = self.env['activity.rule.execution'].new({'trigger_id': trigger})

        try:
            execution_result = instance_rule_execution.execute_code(
                rule,
                activity,
                action=trigger.action_id,  # TODO: query and operation both have action_id, but it's weak
                force_time=force_time,
                package_ids=package_ids)

            if trigger._name == 'device.query':
                execution_status, execution_log = self._parse_query_execution_result(rule, execution_result)
            else:
                execution_status, execution_log = self._parse_operation_execution_result(rule, execution_result)

        except Exception as e:
            # unicode(str(log).decode('utf-8'))
            error_log = ''
            msg = str(e).encode().decode('unicode-escape')
            lines_msg = [line for line in msg.split('\n') if not line.startswith(('#', "'", "u'"))]
            if lines_msg:
                msg = "</error>\n\t\t\t<error>\t".join(
                    [line for line in msg.split('\n') if not line.startswith(('#', "'", "u'"))])
            error_log += "\n\t\t<error>Rule Exception :</error>\n\t\t\t<error>" + str(msg) + "</error>"
            # if not engine_result:
            #     engine_result = self.env['exploitation.engine.result'].new({'trigger': trigger})
            # engine_result.execution_log = unicode(engine_result.execution_log) +
            # engine_result.state = 'error'
            _logger.warning(e, exc_info=True)

            execution_status = EXECUTION_ERROR
            execution_log = self._format_log(error_log)

        return instance_rule_execution, execution_status, execution_log

    @api.model
    def _parse_query_execution_result(self, rule, execution_result):
        """Analyse the execution output, and generate a log and a status.

        :param rule: The activity.rule object executed
        :param execution_result: he temporary rule execution result (dictionary)
        :return: (status <enum>, log <str>)
        """
        log = ''

        # Log des messages
        if execution_result['messages']:
            msg = ''
            for messages_line in execution_result['messages']:
                msg += '\n\t\t\t<info>' + messages_line + '</info>'
            log += '\n\t\tRule log :' + str(msg)

        # Recherches des cas d'erreur
        if execution_result['usages']:
            log += "\n\t\t<error>Error : The rule output usages in query mode</error>"
            return EXECUTION_ERROR, log
        elif execution_result['responses'] and len(execution_result['responses']) > 1:
            log += "\n\t\t<error>Error : To many responses, {nb_response} instead of one</error>".format(
                nb_response=len(execution_result['responses']))
            return EXECUTION_ERROR, log

        # Recherche des cas vide (sans retour)
        elif not execution_result['responses'] and not execution_result['operations']:
            log += "\n\t\tThe rule {rule_name} ({rule_code}) didn't respond to the query".format(
                rule_name=str(rule.name),
                rule_code=str(rule.code))
            return EXECUTION_EMPTY, log
        elif execution_result['operations'] and not execution_result['responses']:
            log += ("\n\t\t<warning>Warning :The rule {rule_name} ({rule_code}) set operations "
                    "but no responses to the query, operations ignored</warning>").format(
                rule_name=str(rule.name),
                rule_code=str(rule.code))
            return EXECUTION_EMPTY, log

        # Cas standard (avec retour)
        else:
            response = execution_result['responses'][0]
            response_is_final = response.get('final', False)
            response_is_yes = response.get('response', False)
            log += ("\n\t\tRule output:"
                    "\n\t\t\tresponse : {type_response}{response_msg}").format(
                type_response="{response_bool}{final}".format(
                    response_bool='YES' if response_is_yes else 'NO',
                    final=' Final' if response_is_final else ''),
                response_msg=' with message: ' + response.get('message', '')
                if response.get('message', False) else
                ' without message')
            for operation in execution_result['operations'] or []:
                log += ("\n\t\t\toperation : quantity {quantity}, action {action}, activity {activity},"
                        " compute {compute}").format(
                    quantity=operation.get('quantity', '?'),
                    action=operation['action_rec'].code
                    if operation.get('action_rec', False)
                    else '?',
                    activity=operation['activity_rec'].reference
                    if operation.get('activity_rec', False)
                    else '?',
                    compute='Yes' if operation['disable_computation'] else 'No')

            if response_is_final:
                execution_status = EXECUTION_FINAL
            elif not response_is_yes:
                execution_status = EXECUTION_RESPONSE_NO
            else:
                if not response.get('message', True):
                    execution_status = EXECUTION_RESPONSE_NOMESSAGE
                else:
                    execution_status = EXECUTION_OK

        return execution_status, log

    @api.model
    def _parse_operation_execution_result(self, rule, execution_result):
        """Analyse the execution output, and generate a log and a status.

        :param rule: The activity.rule object executed
        :param execution_result: he temporary rule execution result (dictionary)
        :return: (status <enum>, log <str>)
        """
        log = ''

        # Log des messages
        if execution_result['messages']:
            msg = ''
            for messages_line in execution_result['messages']:
                msg += '\n\t\t\t<info>' + messages_line + '</info>'
            log += '\n\t\tRule log :' + str(msg)

        # Recherches des cas d'erreur
        if execution_result['responses']:
            log += "\n\t\t<error>Error : The rule output a responses in operation mode</error>"
            return EXECUTION_ERROR, log

        # Recherche des cas vide (sans retour)
        elif not execution_result['usages'] and not execution_result['operations']:
            log += "\n\t\tThe rule {rule_name} ({rule_code}) didn't respond to the operation".format(
                rule_name=str(rule.name),
                rule_code=str(rule.code))
            return EXECUTION_EMPTY, log

        # Cas standard (avec retour)
        else:
            # TODO: add an operation detection to avoid infinite loop (an operation creating a similar operation)
            log += "\n\t\tRule output:"
            for rule_usage in execution_result['usages'] or []:
                log += "\n\t\t\t▶ usage : quantity {quantity}, activity {activity}, mode {mode}".format(
                    quantity=rule_usage.get('quantity', '?'),
                    activity=rule_usage['activity_rec'].reference
                    if rule_usage.get('activity_rec', False)
                    else '?',
                    mode=rule_usage.get('mode', '?'))
            for operation in execution_result['operations'] or []:
                log += ("\n\t\t\toperation : quantity {quantity}, action {action}, activity {activity},"
                        " compute {compute}").format(
                    quantity=operation.get('quantity', '?'),
                    action=operation['action_rec'].code
                    if operation.get('action_rec', False)
                    else '?',
                    activity=operation['activity_rec'].reference
                    if operation.get('activity_rec', False)
                    else '?',
                    compute='Yes' if operation['disable_computation'] else 'No')

        return EXECUTION_FINAL, log

    @api.multi
    def _get_custom_query_json(self):
        self.ensure_one()
        action = None
        tag = None
        device = None
        check_point = None
        if self.action_id:
            action = self.action_id.read(fields=['code', 'id', 'name', 'type'])[0]
        if self.tag_id:
            tag = self.tag_id.read(fields=['active', 'create_date', 'medium_id',
                                           'number', 'display_name', 'mapping_id'])[0]
        elif self.custom_tag_number:
            tag = {'number': self.custom_tag_number}
        if self.device_id:
            device = self.device_id.read(fields=['check_point_ids', 'name', 'unique_id'])[0]
        if self.check_point_id:
            check_point = self.check_point_id.read(fields=['code', 'device_id', 'name'])[0]
        elif self.custom_check_point:
            check_point = {'code': self.custom_check_point}
        query = {
            'action': action,
            'tag': tag,
            'device': device,
            'check_point': check_point,
            'create_date': self.query_time or fields.datetime.now()
        }
        return json.dumps(query, indent=2, sort_keys=True)

    @api.multi
    def _self_refresh_wizard(self):
        return {
            'context': self.env.context,
            'type': 'ir.actions.act_window',
            'res_model': self._name,
            'res_id': self.id,
            'view_mode': 'form',
            'target': 'new',
        }

        # return {
        #     # TODO : une action vide pourrait être créée (action_manager.js) appelée ir.action.do_noting
        #     "type": "set_scrollTop",
        # }

    @api.model
    def _cron_compute_operation(self, options):
        """Cron method to compute periodically.

        :param options: dict(force, max_retry, limit) parameters for cron mechanic:
            - force: force update for every records
            - try_number: try limit of synchronization
            - limit: maximum records sent by request
        :return: nothing
        """
        # _logger.info("Cron engine called")
        search_filter = [('state', '=', 'new')]
        limit = int(options.get('limit', 50))
        rec_to_compute = self.env['horanet.operation'].sudo().search(search_filter, limit=limit, order='time asc')

        if rec_to_compute:
            start_time = time.time()
            rec_to_compute.write({'state': 'pending'})
            _logger.info("Cron engine : start operation processing: " + str(rec_to_compute.ids))
            for operation in rec_to_compute:
                operation.action_force_recompute()
            _logger.info("Cron engine : done operation processing (Total runtime: {exec_time:0.3f}s)".format(
                exec_time=round(time.time() - start_time, 3)))

    # endregion

    pass
