import logging

try:
    from odoo.addons.mail.models.mail_template import format_tz
except ImportError:
    raise ImportError

from odoo import models, fields, api, exceptions, _
from odoo.osv import expression
import ast
from datetime import datetime

_logger = logging.getLogger(__name__)

OPERATION_STATE = [('new', 'New'),
                   ('null', 'Empty'),
                   ('error', 'Error'),
                   ('pending', 'Pending'),
                   ('no_compute', 'No compute'),
                   ('processed', 'Processed')]


class HoranetOperation(models.Model):
    """Représente les fait (immuable).

    Les fait sont des constatation d'action remontés du terrain ou virtuels, exemple:
      - Une borne a détecté un badgeage
      - Un personne est entrée dans un bâtiment
    """

    # region Private attributes
    _name = 'horanet.operation'
    _order = 'time desc'

    # endregion

    # region Default methods
    # endregion

    # region Fields declaration
    display_name = fields.Char(string="Name", compute='compute_display_name')

    state = fields.Selection(string="State", selection=OPERATION_STATE, default='new',
                             compute='_compute_state',
                             store=True)
    device_id = fields.Many2one(string="Device", comodel_name='horanet.device', required=False)
    action_id = fields.Many2one(string="Action", comodel_name='horanet.action', required=True)
    time = fields.Datetime(string="Time", required=True, default=fields.Datetime.now)

    is_offline = fields.Boolean(string="Is offline", default=False)
    number = fields.Char(string="number")

    quantity = fields.Float(string="Quantity", default=1.0)
    query_id = fields.Many2one(string="Query", comodel_name='device.query')
    tag_id = fields.Many2one(
        string="Medium used",
        comodel_name='partner.contact.identification.tag',
        required=False,
        index=True,
        store=True,
    )
    partner_id = fields.Many2one(
        string="Partner",
        comodel_name='res.partner',
        index=True,
        store=True,
    )
    check_point_id = fields.Many2one(string="Check point", comodel_name='device.check.point')
    activity_sector_id = fields.Many2one(string="Activity sector", comodel_name='activity.sector')
    activity_id = fields.Many2one(string="Activity", comodel_name='horanet.activity')

    activity_uom_id = fields.Many2one(string="Measure unit",
                                      related='activity_id.product_uom_id', readonly=True)

    sale_order_line_ids = fields.Many2many(string="Sale order lines", comodel_name='sale.order.line',
                                           compute='_get_related_sale_order_lines')
    disable_computation = fields.Boolean(string="Disabled computation", default=False)

    # region exploitation engine
    resulting_engine_result_id = fields.Many2one(
        string="Exploitation engine result",
        comodel_name='exploitation.engine.result')
    resulting_operation_ids = fields.One2many(
        string="Resulting operations", comodel_name='horanet.operation',
        related='resulting_engine_result_id.operation_ids')
    resulting_usage_ids = fields.One2many(
        string="Resulting usages", comodel_name='horanet.usage',
        related='resulting_engine_result_id.usage_ids')
    resulting_execution_log = fields.Text(
        string="Execution log",
        related='resulting_engine_result_id.execution_log')

    origin_engine_result_id = fields.Many2one(
        string="Origine exploitation engine result",
        comodel_name='exploitation.engine.result',
        ondelete='restrict')
    origin_operation_id = fields.Many2one(
        string="Origin operation", comodel_name='horanet.operation',
        related='origin_engine_result_id.trigger_operation_id')
    origin_query_id = fields.Many2one(
        string="Origin query", comodel_name='device.query',
        related='origin_engine_result_id.trigger_query_id')
    origin_execution_log = fields.Text(
        string="Execution log",
        related='origin_engine_result_id.execution_log')
    # endregion
    linked_operation_ids = fields.Many2many(string="Linked operations", comodel_name='horanet.operation',
                                            relation='horanet_operation_linked_rel',
                                            column1='operation_origin_id',
                                            column2='operation_linked_id',
                                            store=True)

    operation_partner_id = fields.Many2one(
        string="Resolved partner",
        comodel_name='res.partner',
        compute='_compute_operation_partner_id',
        search='_search_operation_partner_id',
        readonly=True,
        store=False,
    )
    partner_sub_category_ids = fields.Many2many(
        string="Subscription categories",
        comodel_name='subscription.category.partner',
        compute='_compute_partner_sub_category_ids',
        search='_search_partner_sub_category_ids',
        readonly=True,
        store=False,
    )

    infrastructure_id = fields.Many2one(
        string='Infrastructure',
        comodel_name='horanet.infrastructure',
        store=True  # Needed to be able to group by on this field...
    )

    # endregion

    # region Fields method
    @api.depends('resulting_engine_result_id', 'resulting_engine_result_id.state', 'disable_computation')
    def _compute_state(self):
        for operation in self:
            if operation.disable_computation:
                operation.state = 'no_compute'
            elif not operation.resulting_engine_result_id:
                operation.state = 'new'
            elif operation.resulting_engine_result_id.state == 'null':
                operation.state = 'null'
            elif operation.resulting_engine_result_id.state == 'error':
                operation.state = 'error'
            elif operation.resulting_engine_result_id.state == 'done':
                operation.state = 'processed'

    @api.depends('time', 'action_id', 'quantity')
    def compute_display_name(self):
        for op in self:
            op_date = format_tz(self.env, op.time)
            op.display_name = "{}: {} {}".format(op_date, str(op.quantity), op.action_id.name)

    @api.depends('tag_id', 'partner_id', 'time')
    def _compute_operation_partner_id(self):
        u"""Recherche des partner liée aux opération.

        Le partenaire lié à l'opération est déterminé en fonction de la date de l'opération ainsi que de
        l'objet référencé par l'opération.
        """
        operations_with_partner = self.filtered('partner_id')
        operations_without_partner = self - operations_with_partner

        for operation_with_partner in operations_with_partner:
            operation_with_partner.operation_partner_id = operation_with_partner.partner_id

        # Pour fortement gagner en performance, l'on recherche les partner liées aux tag en python.
        # Cela évite de faire une requête SQL par opération, car il fait recherche l'assignation qui
        # correspond au moment de réalisation du fait.
        if len(operations_without_partner) > 1:

            sorted_operation = operations_without_partner.sorted('time')
            # recherche des assignations et des partners liée aux tags d'opérations
            partner_by_tag = operations_without_partner.mapped('tag_id').get_partner_linked_to_multiple_tag(
                start_date=sorted_operation[0].time,
                end_date=sorted_operation[-1].time)

            # partner_by_tag est de la forme : {tag_rec: [(date_start, date_end, partner_rec]}
            for operation in operations_without_partner:
                operation.operation_partner_id = next(
                    (a[2] for a in partner_by_tag[operation.tag_id] if
                     a[0] <= operation.time and (not a[1] or a[1] >= operation.time)),
                    None)

        elif operations_without_partner and operations_without_partner.tag_id:
            operations_without_partner.operation_partner_id = \
                operations_without_partner.tag_id.get_partner_linked_to_tag(
                    search_date_utc=operations_without_partner.time)

    def _search_operation_partner_id(self, operator, value):
        """Recherche les opérations d'un partner.

        Si l'opération est liée à un partner on retrouve ce partner et si elle est liée à un badge qui est lui même
        lié à un forfait, on retrouve le partner du forfait.

        :param operator: the search operator
        :param value: string for a search by name, or int or list(<int>) for a search by id
        :return: A search domain
        """
        if not isinstance(value, int) and not isinstance(value, str) and not isinstance(value, list) \
                or isinstance(value, bool):
            raise TypeError(
                "Search partner on tags: Expected integer or list of integer or string, found {bad_type}".format(
                    bad_type=str(type(value)))
            )

        if isinstance(value, str):
            value = self.env['res.partner'].with_context(prefetch_fields=False).search([('name', 'ilike', value)]).ids
            # On limite la taille de la recherche à 10 partners afin de traiter les doublons et ne pas surcharger odoo.
            if len(value) > 10:
                raise exceptions.UserError(_("Search terms are too large. Please be more specific."))
            else:
                value = list(value)
        if isinstance(value, int):
            value = [value]

        domain = []
        partner_package = self.env['horanet.package'].search([
            ('recipient_id', 'in', value),
        ])
        partner_assignation = self.env['partner.contact.identification.assignation'].search([
            '|',
            ('partner_id', 'in', value),
            ('package_id', 'in', partner_package.ids),
        ])

        for assignation in partner_assignation:
            # on explicite tag_id != False car tag_id est un many2one non obligatoire, donc il peut avoir une valeur
            # null. Or si on ne l'explicite pas, lors d'une recherche négative odoo ne prendra pas en compte ceux ayant,
            # une valeur null.
            assignation_domain = [('tag_id', '!=', False),
                                  ('tag_id', '=', assignation.tag_id.id),
                                  ('time', '>=', assignation.start_date)]

            if assignation.end_date:
                assignation_domain += [('time', '<', assignation.end_date)]
            domain = expression.OR([domain, expression.normalize_domain(assignation_domain)])

        # On explicite partner_id != False pour la même raison que précédemment
        domain = expression.OR([domain, ['&', ('partner_id', '!=', False), ('partner_id', 'in', value)]])

        if operator in expression.NEGATIVE_TERM_OPERATORS:
            domain = [expression.NOT_OPERATOR] + expression.normalize_domain(domain)

        return expression.normalize_domain(domain)

    @api.depends('partner_id')
    def _compute_partner_sub_category_ids(self):
        for rec in self:
            if rec.partner_id:
                rec.partner_sub_category_ids = rec.partner_id.subscription_category_ids
            else:
                rec.partner_sub_category_ids = None

    def _search_partner_sub_category_ids(self, operator, value):
        """Recherche les tags dont l'éventuel partner (via assignation) possède l'une des catégories."""
        result = expression.FALSE_DOMAIN
        # 1- Vérification des opérateurs supportés
        if operator not in ['=', '!=', 'in', 'not in']:
            return result

        # 2- Vérification de la valeur
        if isinstance(value, str):
            categories = self.subscription_category_ids.search([('code', operator, value)])
        elif operator in ['in', 'not in', '=', '!=']:
            categories = self.env['subscription.category.partner']
            if isinstance(value, models.Model) and value._name == 'subscription.category.partner':
                categories = value
            elif value and isinstance(value, int):
                categories = categories.browse([value])
            elif value and isinstance(value, list):
                categories = categories.browse(value)

        domains = [expression.normalize_domain(ast.literal_eval(domain)) for domain in categories.mapped('domain')]
        if domains:
            domains = expression.AND(domains)
        if operator in expression.NEGATIVE_TERM_OPERATORS:
            domains = [expression.NOT_OPERATOR] + domains
        partner_ids = self.env['res.partner'].search(expression.normalize_domain(domains)).ids
        tag_ids = self.env['partner.contact.identification.tag'].search([('partner_id', 'in', partner_ids)])

        if tag_ids:
            result = [('tag_id', 'in', tag_ids.ids)]

        return expression.normalize_domain(result)

    @api.depends('resulting_usage_ids')
    def _get_related_sale_order_lines(self):
        """Get the sale order lines of the usages."""
        for rec in self:
            if rec.resulting_usage_ids:
                rec.sale_order_line_ids = rec.resulting_usage_ids.mapped('sale_order_line_id')

    # endregion

    # region Constraints and Onchange
    @api.constrains('tag_id', 'partner_id')
    def _constraint_identification(self):
        if self.tag_id and self.partner_id:
            raise exceptions.ValidationError(_("An operation can only have a partner OR a tag, not both"))

    # endregion

    # region CRUD (overrides)
    @api.multi
    def name_get(self):
        res = []
        for operation in self:
            name = str(operation.quantity) + ' ' + operation.action_id.name + ' at ' + str(
                operation.time) + ' - ' + str(operation.state)
            res.append((operation.id, name))
        return res
    # endregion

    # region Actions
    @api.multi
    def action_force_recompute(self):
        # TODO: gérer les sealed et warning
        _logger.debug('Manual operation computation (ids:' + str(self.ids) + ')')
        if 'no_compute' in self.mapped('state'):
            raise exceptions.ValidationError(_("An operation flagged a 'no computation' cannot be computed"))
        self.mapped('resulting_engine_result_id').unlink(engine_force=True)

        for rec in self:
            engine = self.env['exploitation.engine'].new({'trigger': rec})
            result = engine.compute(force_time=rec.time, simulation=False)

            rec.resulting_engine_result_id = result

    @api.multi
    def action_open_wizard_sandbox(self):
        """Appel du wizard d'éxécution sandbox sur l'opération courante."""
        self.ensure_one()

        # self.state = 'new'
        wizard_view = self.env.ref('horanet_subscription.wizard_activity_rule_sandbox_form')
        wizard_rec = self.env['activity.rule.wizard.sandbox'].create({
            'input_mode': 'operation',
            'query_time': self.time,
            'action_id': self.action_id.id,
            'device_id': self.device_id.id,
            'tag_id': self.tag_id.id,
            'partner_id': self.partner_id.id,
            'check_point_id': self.check_point_id.id,
            'operation_is_offline': self.is_offline,
            'operation_quantity': self.quantity,
            'operation_activity_id': self.activity_id.id,
            'operation_query_id': self.query_id.id,
            'operation_sector_id': self.activity_sector_id.id,
        })
        return {
            'context': self.env.context,
            'type': 'ir.actions.act_window',

            'res_model': 'activity.rule.wizard.sandbox',
            'src_model': 'horanet.operation',
            'res_id': wizard_rec.id,

            'view_id': wizard_view.id,
            'view_mode': 'form',
            'view_type': 'form',
            'target': 'new',
            'name': 'Operation Sandbox redirection',
        }

    # endregion

    # region Model methods
    @api.multi
    def to_string(self):
        result = []
        for operation in self:
            activity_str = ''
            if operation.activity_id:
                activity_str = "activity {activity_name}".format(activity_name=operation.activity_id.name)

            operation_to_string = "quantity {quantity}, action {action_name} ({action_code}) {activity_str}".format(
                quantity=operation.quantity or '0',
                action_name=operation.action_id.name,
                action_code=operation.action_id.code,
                activity_str=activity_str)
            result.append((operation.id or None, operation_to_string))
        return result

    @api.multi
    def check_validity(self):
        if not self.activity_id and not self.activity_sector_id and not self.check_point_id:
            raise AttributeError("An operation without activity must have a sector or a check_point")

    def get_operation_linked_packages(self, force_time=False):
        """Permet de retrouver les forfaits correspondant au paramétrage d'une opération."""
        self.ensure_one()
        search_time = force_time or self.time or datetime.now()
        packages = self.env['horanet.package']
        log = ''
        if not self.tag_id and not self.partner_id:
            log = "\n\tNo activities found (no Tag or Partner provided)"
        else:
            if self.partner_id:
                packages = packages.search([('recipient_id', '=', self.partner_id.id)])
                log += "\n\tResolve packages using Partner {partner_hyperlink}".format(
                    partner_hyperlink=('<a href=\"/web#id={model_id}&view_type=form&model=res.partner\">'
                                       '{text}</a>').format(
                        model_id=str(self.partner_id.id),
                        text=self.partner_id.name + ' - ' + str(self.partner_id.id)))
            elif self.tag_id:
                tag_linked_partner = self.tag_id.get_tag_partner(search_date_utc=search_time)
                tag_hyperlink = ('<a href=\"/web#id={model_id}'
                                 '&view_type=form&model=partner.contact.identification.tag\">'
                                 '{text}</a>').format(
                    model_id=str(self.tag_id.id),
                    text=self.tag_id.number)
                partner_hyperlink = ''
                if tag_linked_partner:
                    partner_hyperlink = ('<a href=\"/web#id={model_id}'
                                         '&view_type=form&model=res.partner\">'
                                         '{text}</a>').format(
                        model_id=str(tag_linked_partner.id),
                        text=tag_linked_partner.name + ' - ' + str(tag_linked_partner.id))

                log += "\n\tResolve packages using Tag {tag_hyperlink} {partner_link}".format(
                    tag_hyperlink=tag_hyperlink,
                    partner_link="(no partner linked with this tag)" if not tag_linked_partner else
                    "(linked to partner {partner_hyperlink})".format(partner_hyperlink=partner_hyperlink))

                packages = self.tag_id.get_tag_linked_package(given_date=search_time)

        return packages, log

    # endregion

    pass
