import logging
from contextlib import contextmanager

from odoo import models, fields, api, exceptions, _
from odoo.exceptions import ValidationError
from odoo.osv import expression
from odoo.tools.safe_eval import test_python_expr

_logger = logging.getLogger(__name__)


class HoranetActivityRuleVersion(models.Model):
    """This model contain all data needed to process a rule, it's a version of a concept known as activity.rule.

    This model is meant to store a rule version and as such shouldn't never be modified (apart from the modification
    of the field 'active')

    This class contain all methods relative to the rule_code execution
    """

    # region Private attributes
    _name = 'activity.rule.version'
    # TODO : add constrain on write/create to informe user on wich rule conflict
    _sql_constraints = [
        # ('unicity_on_code', 'UNIQUE(active,code)', _("The rule code must be unique if not null")),
        ('positive_priority', 'CHECK(priority >= 0)', _("The priority must positive")),
        # Partial constraint, complemented by unique index (see below on '_auto_init'). Still
        # useful to keep because it provides a proper error message when a violation occurs
        # ('unicity_on_priority', 'UNIQUE(activity_sector_id, priority)', _("Conflicting rule priority !"))
    ]

    # endregion

    # region Default methods
    @api.model
    def default_code(self):
        """Return a default code value based on a sequence."""
        return self.env['ir.sequence'].next_by_code('activity.rule.code')

    @api.model
    def default_rule_code(self):
        """Return code value, used to display usage informations."""
        return ("# Write here your rule code\n"
                "# Exemple method:\n"
                "#   response(True, \"message to display\")\n"
                "#   operation(1, action, activity)\n"
                "# Global variable:\n"
                "#   QUERY (if trigger by a query)\n"
                "#     or\n"
                "#   OPERATION (if trigger by an operation)\n"
                "#   activity\n"
                "#   action\n"
                )

    # endregion

    # region Fields declaration
    name = fields.Char(string="Name", required=True)
    active = fields.Boolean(string="Active", readonly=True, default=True)
    enabled = fields.Boolean(string="Enabled", readonly=True, default=True)
    code = fields.Char(string="Reference", required=True, default=default_code, readonly=True)
    priority = fields.Integer(string="Priority", default=10, required=True)

    beginning_date = fields.Date(string='Beginning date', default=fields.Date.context_today, required=True)
    ending_date = fields.Date(string='Ending date')

    rule_code = fields.Text(string="Code", required=True, default=default_rule_code,
                            help="Use method response(authorize<bool>,message<string optional>)")
    embedded_rule_code = fields.Text(string="Code in function",
                                     compute='_get_embedded_rule_code',
                                     store=True)
    description = fields.Text(string="Description")

    action_ids = fields.Many2many(string="Actions", comodel_name='horanet.action')

    use_sector_activity = fields.Boolean(string="Use sector activities", default=False)
    custom_activity_ids = fields.Many2many(string="Custom activities", comodel_name='horanet.activity')
    activity_ids = fields.Many2many(string="Activities", comodel_name='horanet.activity',
                                    compute='_compute_activity_ids', store=False,
                                    search='_search_activity_ids')
    activity_sector_id = fields.Many2one(string="Activity sector", comodel_name='activity.sector')

    last_error_message = fields.Text(string="Last error message")
    last_execution_date = fields.Datetime(string="Last execution date")

    has_error = fields.Boolean(string="Has error", default=False)
    version = fields.Integer(string="Version", default=1, readonly=True)
    previous_version_ids = fields.Many2many(string="Previous versions", comodel_name='activity.rule.version',
                                            compute='_compute_previous_version_ids', store=False)

    # endregion

    # region Fields method
    @api.depends('version')
    def _compute_previous_version_ids(self):
        """Compute the old versions of this rule.

        :return: Nothing
        """
        for rec in self:
            old = self.with_context(active_test=False).search(
                [('code', '=', self.code), ('version', '<', self.version), ('active', '=', False)],
                order='version desc')
            rec.previous_version_ids = old

    @api.depends('rule_code')
    def _get_embedded_rule_code(self):
        """Include the sourcecode as the code of a function _embeddedRuleCode_."""
        for rule in self:
            embedded_string = "def _embeddedRuleCode_(*args, **kwargs):\n"
            embedded_string += "\t" + "\n\t".join(rule.rule_code.split('\n')) \
                               + "\n\tpass\n_embeddedRuleCode_()\n"
            rule.embedded_rule_code = embedded_string

    @api.depends('use_sector_activity', 'custom_activity_ids', 'activity_sector_id', 'activity_sector_id.activity_ids')
    def _compute_activity_ids(self):
        """Compute the activities bind to this rule, using the sector if necessary."""
        for rule in self:
            if rule.use_sector_activity and rule.activity_sector_id:
                rule.activity_ids = rule.activity_sector_id.activity_ids
            else:
                rule.activity_ids = rule.custom_activity_ids

    @api.model
    def _search_activity_ids(self, operator, value=False):
        """Perform a fast research on activities (used to find the rule to execute).

        :param operator: opérateur de recherche
        :param value: valuer recherché
        :return: Retourne un domain de recherche correspondant à la recherche sur le champ calculé activity_ids
        """
        search_domain = [
            '|',
            '&',
            '&',
            ('use_sector_activity', '=', True),
            ('activity_sector_id', '!=', False),
            ('activity_sector_id.activity_ids', operator, value),
            ('custom_activity_ids', operator, value),
        ]
        # inversion en cas de recherche négative
        if operator in expression.NEGATIVE_TERM_OPERATORS:
            search_domain = expression.NOT_OPERATOR + search_domain

        return search_domain

    # endregion

    # region Constrains and Onchange
    @api.onchange('rule_code')
    def onchange_rule_code(self):
        """Validate rule_code to try to detect some errors."""
        if self.rule_code:
            test_python_expr(self.rule_code)

    @api.onchange('activity_sector_id')
    def onchange_parent_id(self):
        """Disabled the option to used sector activity if sector no sector selected."""
        self.ensure_one()
        if not self.activity_sector_id:
            self.use_sector_activity = False
        elif not self.custom_activity_ids:
            self.use_sector_activity = True

    @api.constrains('activity_sector_id', 'use_sector_activity')
    def check_sector_activity(self):
        for rec in self:
            if rec.use_sector_activity and not rec.activity_sector_id:
                raise exceptions.ValidationError(
                    _("The rule must have a sector in order to use it's activities"))

    @api.constrains('activity_sector_id', 'use_sector_activity', 'custom_activity_ids')
    def check_activity_ids(self):
        for rec in self:
            if rec.activity_sector_id and not rec.custom_activity_ids and not rec.use_sector_activity:
                raise exceptions.ValidationError(
                    _("The rule must use sector activities if no custom activities are set"))

    # endregion

    # region CRUD (overrides)
    @api.model_cr_context
    def _auto_init(self):
        """Add a partial index to enforce unicity of rule priority by sector.

        when the sector is not defined. This is not possible using a constraint)
        """
        res = super(HoranetActivityRuleVersion, self)._auto_init()

        # Use unique index to implement unique constraint on active record (not possible using a constraint)
        idx_name = 'activity_rule_unique_code'
        # TODO : a supprimer un fois stabilisé (la suppression de l'index)
        self._cr.execute("DROP INDEX IF EXISTS {idx_name}".format(idx_name=idx_name))
        self._cr.execute("SELECT indexname FROM pg_indexes WHERE indexname = '{idx_name}'".format(idx_name=idx_name))
        if not self._cr.fetchone():
            sql_query = "CREATE UNIQUE INDEX {idx_name} ON {table_name} (code) where active=true"
            self._cr.execute(sql_query.format(idx_name=idx_name, table_name=self._table))

        idx_name = 'activity_rule_unique_global_priority'
        self._cr.execute("DROP INDEX IF EXISTS {idx_name}".format(idx_name=idx_name))
        self._cr.execute("SELECT indexname FROM pg_indexes WHERE indexname = '{idx_name}'".format(idx_name=idx_name))
        if not self._cr.fetchone():
            sql_query = ("CREATE UNIQUE INDEX {idx_name} ON {table_name} (priority) "
                         "where active=true AND activity_sector_id IS NULL")
            self._cr.execute(sql_query.format(idx_name=idx_name, table_name=self._table))

        idx_name = 'activity_rule_unique_priority_by_sector'
        self._cr.execute("DROP INDEX IF EXISTS {idx_name}".format(idx_name=idx_name))
        self._cr.execute(
            "SELECT indexname FROM pg_indexes WHERE indexname = '{idx_name}'".format(idx_name=idx_name))
        if not self._cr.fetchone():
            sql_query = ("CREATE UNIQUE INDEX {idx_name} ON {table_name} (activity_sector_id, priority) "
                         "where active=true")
            self._cr.execute(sql_query.format(idx_name=idx_name, table_name=self._table))
        return res

    @api.multi
    def write(self, vals):
        """Overwrite write method used to restrict alteration on record.

        Only the field active can be set, in order to avoid breaking unicity constraint
        :param vals: dict vals: fields to update and the value to set on them
        :raise ValidateError: if user tries to modify a rule version on any other field than 'active'
        :return: True if no problems found
        """
        if not self:
            return True
        self._check_concurrency()
        self.check_access_rights('write')
        if all([k in ['active'] for k in list(vals.keys())]):
            return super(HoranetActivityRuleVersion, self).write(vals)
        elif len(self) > 0:
            raise ValidationError(
                _("Activity rule version edition is forbidden. rule id {rule_id}").format(
                    rule_id=','.join(map(str, self.ids))))
        return True

    @api.multi
    def name_get(self):
        """Return a textual representation for the records in ``self``.

        By default this is the value of the ``display_name`` field.

        :return: list of pairs ``(id, text_repr)`` for each records
        :rtype: list(tuple)
        """
        result = []
        for rec in self:
            result.append((rec.id, str(rec.name) + " (" + str(rec.code) + ")"))
        return result

    # endregion

    # region Actions
    # endregion

    # region Model methods
    @staticmethod
    def cast_unicode(string):
        if isinstance(string, str):  # nothing to do if type unicode
            try:
                string = string.encode().decode('ascii')
            except UnicodeDecodeError:
                string = string.encode().decode('utf-8')
        return string

    # endregion

    pass


@contextmanager
def safe_environment(environment, uid=None):
    """Return an environment with a new test cursor for the current environment database.

    The cursor will never be committed (thus preventing any alteration on the DB)
    but will be closed after the context block.
    """
    if not hasattr(environment, 'registry'):
        raise AttributeError('This method is meant to be called with an Odoo environment')

    try:
        environment.registry.enter_test_mode()
        yield api.Environment(environment.registry.test_cr, uid or environment.uid, environment.context)
    finally:
        environment.registry.leave_test_mode()

    pass
