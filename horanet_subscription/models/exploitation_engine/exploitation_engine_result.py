import logging

from odoo import models, api, fields, exceptions, _

try:
    from odoo.addons.horanet_go.tools import utils as hgo_utils
except ImportError:
    from horanet_go.tools import utils as hgo_utils

_logger = logging.getLogger(__name__)
EXECUTION_ENGINE_STATE = [('null', 'Empty'), ('error', 'Error'), ('done', 'Done')]


class ExecutionEngineResult(models.Model):
    """To do.

    dirty field features can be controlled through context keys :

    - ``force_dirty``: in the context will trigger the dirty flag on a field

    exemple :
    '<field name="XXX" context="{'force_dirty':True}"></field>'
    """

    # region Private attributes
    _name = 'exploitation.engine.result'
    _description = 'Memory record management'
    _order = 'create_date desc'
    _sql_constraints = [
        ('unicity_on_trigger_query', 'UNIQUE(trigger_query_id)', _("A result already exists for this query")),
        ('trigger_operation', 'UNIQUE(trigger_operation_id)', _("A result already exists for this operation")),
    ]
    # endregion

    # region Default methods
    # endregion

    # region Fields declaration
    name = fields.Char(string="Name", compute='_compute_name')
    execution_log = fields.Text(string="Execution log")

    trigger_query_id = fields.Many2one(
        string="Trigger query",
        comodel_name='device.query')
    trigger_operation_id = fields.Many2one(
        string="Trigger operation",
        comodel_name='horanet.operation')

    error_log = fields.Text(string="Error log")
    is_error = fields.Boolean(string="Is error", default=True)
    state = fields.Selection(string="State", selection=EXECUTION_ENGINE_STATE, default='null')

    operation_ids = fields.One2many(
        string="Resulting operations",
        ondelete='restrict',
        comodel_name='horanet.operation',
        inverse_name='origin_engine_result_id')
    response_id = fields.One2many(
        string="Resulting responses",
        ondelete='restrict',
        comodel_name='device.response',
        inverse_name='origin_engine_result_id')
    usage_ids = fields.One2many(
        string="Resulting usages",
        ondelete='restrict',
        comodel_name='horanet.usage',
        inverse_name='origin_engine_result_id')

    # endregion

    # region Fields method
    @api.constrains('trigger_query_id', 'trigger_operation_id')
    def check_validity(self):
        for result in self:
            if not result.trigger_query_id and not result.trigger_operation_id:
                raise exceptions.ValidationError(
                    _("Invalid exploitation engine result : must have a reference to a trigger (operation or query)"))

    @api.depends('trigger_query_id', 'trigger_operation_id')
    def _compute_name(self):
        for result in self:
            if result.trigger_query_id:
                result.name = 'Result for query trigger id:{id}'.format(
                    id=str(result.trigger_query_id.id),

                )
            elif result.trigger_operation_id:
                result.name = 'Result for operation trigger id:{id} {display_name}'.format(
                    id=str(result.trigger_operation_id.id),
                    display_name=str(result.trigger_operation_id.display_name))
            else:
                result.name = 'Result {id}'.format(id=result.id)

    # @api.depends('is_error', 'operation_ids', 'response_id', 'usages_ids', 'trigger_query_id', 'trigger_operation_id')
    # def _compute_state(self):
    #     for result in self:
    #         if result.is_error:
    #             result.state = 'error'
    #         if result
    # endregion

    # region Constrains and Onchange
    # endregion

    # region CRUD (overrides)
    @api.multi
    def unlink(self, engine_force=False):
        if engine_force:
            for engine_result in self:
                engine_result.operation_ids.unlink()
                engine_result.usage_ids.unlink()
        return super(ExecutionEngineResult, self).unlink()

    @api.model
    def new(self, values=False):
        """Surcharge du Create pour y ajouter le paramètre trigger.

        Le paramètre 'trigger' qui représente aussi bien un record du modèle device.query que horanet.operation
        (les deux modèle pouvant déclencher le calcul du moteur d'exploitation)
        Objectif : permettre la création de exploitation.engine avec un trigger polymorphe
        """
        values = values or {}  # Default argument value is mutable
        self.env.context = hgo_utils.clear_context_default_value(self.env.context)
        defaults = self.default_get(self._fields)
        defaults.update(values)
        values = defaults
        if 'trigger' in values:
            if values['trigger'] and isinstance(values['trigger'], models.Model):
                if values['trigger']._name in ['device.query', 'horanet.operation']:
                    if values['trigger']._name == 'device.query':
                        values.update({'trigger_query_id': values['trigger']})
                    else:
                        values.update({'trigger_operation_id': values['trigger']})
                else:
                    raise Exception("Argument 'trigger' should be a device.query or horanet.operation record")
        return super(ExecutionEngineResult, self).new(values)

    # endregion

    # region Actions
    @api.multi
    def action_open_wizard_sandbox(self):
        """Appel du wizard d'éxécution sandbox sur le résultat courant."""
        self.ensure_one()

        wizard_view = self.env.ref('horanet_subscription.wizard_activity_rule_sandbox_form')
        commun_trigger = self.trigger_query_id or self.trigger_operation_id
        wizard_rec = self.env['activity.rule.wizard.sandbox'].create({
            'input_mode': 'query' if self.trigger_query_id else 'operation',
            'query_time': commun_trigger.create_date if self.trigger_query_id else commun_trigger.time,
            'action_id': commun_trigger.action_id.id,
            'device_id': commun_trigger.device_id and commun_trigger.device_id.id or False,
            'tag_id': commun_trigger.tag_id and commun_trigger.tag_id.id,
            'check_point_id': commun_trigger.check_point_id and commun_trigger.check_point_id.id or False,
            'operation_is_offline': self.trigger_operation_id and self.trigger_operation_id.is_offline,
            'operation_quantity': self.trigger_operation_id and self.trigger_operation_id.quantity,
            'operation_activity_id': self.trigger_operation_id and self.trigger_operation_id.activity_id.id,
            'operation_query_id': self.trigger_operation_id and self.trigger_operation_id.query_id.id,
            'operation_sector_id': self.trigger_operation_id and self.trigger_operation_id.activity_sector_id.id,
        })
        return {
            'context': self.env.context,
            'type': 'ir.actions.act_window',

            'res_model': 'activity.rule.wizard.sandbox',
            'src_model': 'exploitation.engine.result',
            'res_id': wizard_rec.id,

            'view_id': wizard_view.id,
            'view_mode': 'form',
            'view_type': 'form',
            'target': 'new',
            'name': 'Engine exploitation result Sandbox redirection',
        }

    # endregion

    # region Model methods
    @api.multi
    def set_error(self, error=False):
        self.ensure_one()
        if not error:
            self.is_error = False
        else:
            self.is_error = True
            self.state = 'error'
            if isinstance(error, Exception):
                msg = str(error).encode().decode("unicode-escape")
                msg = "\n".join(msg.split('\n'))
                self.error_log = msg
            elif isinstance(error, str):
                self.error_log = error

    @api.multi
    def save(self):
        self.ensure_one()
        self.env.context = hgo_utils.clear_context_default_value(self.env.context)
        if not isinstance(self.id, models.NewId):
            raise Exception('Only memory record should be saved')
        if self.trigger_query_id and self.trigger_operation_id:
            raise Exception('The result cannot be bind to a query and an operation')
        if not self.trigger_query_id and not self.trigger_operation_id:
            raise Exception('The result must be bind to a query and an operation')
        if self.trigger_query_id and not self.trigger_query_id.id:
            raise Exception('The query must be an existing record')
        if self.trigger_operation_id and not self.trigger_operation_id.id:
            raise Exception('The operation must be an existing record')

        vals = hgo_utils.get_record_values(self)

        # Double M2O between result and trigger to marginally boost perf (during search)
        # TODO : vérifier si un many2o - o2m ne serait pas plus efficace (sécurité des données)
        # work even if the trigger has no id (in memory)
        if self.trigger_operation_id:
            vals.update({'trigger_operation_id': self.trigger_operation_id.id})
        if self.trigger_query_id:
            vals.update({'trigger_query_id': self.trigger_query_id.id})

        result = self.create(vals)
        # bind the trigger to its result
        if self.trigger_query_id:
            self.trigger_query_id.resulting_engine_result_id = result.id
        if self.trigger_operation_id:
            self.trigger_operation_id.resulting_engine_result_id = result.id

        # bind the resulting objects to the trigger
        for operation in self.operation_ids:
            vals = hgo_utils.get_record_values(operation)
            vals.update({'origin_engine_result_id': result.id})
            operation.create(vals)
        for response in self.response_id:
            vals = hgo_utils.get_record_values(response)
            vals.update({'origin_engine_result_id': result.id})
            response.create(vals)
        for usage in self.usage_ids:
            vals = hgo_utils.get_record_values(usage)
            vals.update({'origin_engine_result_id': result.id})
            usage.create(vals)

        return result

    # endregion

    pass
