import datetime
import logging
from functools import partial

from odoo import models, api, fields
from odoo.exceptions import UserError
from odoo.osv.expression import is_leaf
from odoo.tools.safe_eval import safe_eval

try:
    from odoo.addons.horanet_go.tools import utils as hgo_utils
except ImportError:
    from horanet_go.tools import utils as hgo_utils

TRIGGER_TYPE_QUERY = 'query'
TRIGGER_TYPE_OPERATION = 'operation'
_logger = logging.getLogger(__name__)


class ActivityRuleExecution(models.AbstractModel):
    """Model de gestion d'éxécution des règles d'activités.

    Contient les mécanismes de gestion d'éxécution de code python dynamique, dans un context
    sécurisé (safe_eval)
    """

    # region Private attributes
    _name = 'activity.rule.execution'
    _description = 'Management of activity rule execution'

    __responses__ = None
    __operations__ = None
    __usages__ = None
    __log__ = None

    _execution_context = None
    _execution_result = None

    @property
    def execution_result(self):
        if not self._execution_result:
            raise Exception('The execution result should not accessed before the execution')
        return self._execution_result

    @execution_result.setter
    def execution_result(self, value):
        if self._execution_result:
            raise Exception('The execution result should not be overridden')
        self._execution_result = value

    # endregion

    # region Default methods
    # endregion

    # region Fields declaration
    execution_log = fields.Text(
        string="Execution log")
    trigger_id = fields.Reference(
        string="Origin trigger",
        selection=[('device.query', "Query"), ('horanet.operation', "Operation")],
        required=True)
    response_ids = fields.Many2many(string="Resulting responses", comodel_name='device.response')
    operation_ids = fields.Many2many(string="Resulting operations", comodel_name='horanet.operation')
    usage_ids = fields.Many2many(string="Resulting usages", comodel_name='horanet.usage')

    # endregion

    # region Fields method
    # endregion

    # region Constrains and Onchange
    # endregion

    # region CRUD (overrides)
    @api.model
    def search(self, args, offset=0, limit=None, order=None, count=False):
        """Disabled search on trigger_id (field reference) due to an Odoo crm merge bug."""
        for arg in args:
            if is_leaf(arg) and isinstance(arg[0], str) and arg[0] == 'trigger_id':
                return self
        return super(ActivityRuleExecution, self).search(args, offset=offset, limit=limit, order=order, count=count)

    # endregion

    # region Actions
    # endregion

    # region Model methods
    @api.multi
    def clear_result(self):
        self.__responses__ = None
        self.__operations__ = None
        self.__usages__ = None
        self.__log__ = None
        self._execution_result = None
        self.response_ids = None
        self.operation_ids = None
        self.execution_log = None
        self.usage_ids = None
        self._execution_context = None

    @api.multi
    def execute_code(self, rule, activity, action, force_time=None, package_ids=False):
        """Execute a rule in a safe environment.

        :param rule: The activity.rule record containing the executable code
        :param activity: An horanet.activity, bound to the execution context
        :param action: the context action
        :param force_time: Optional, the execution context time (default = server time)
        :param package_ids: Optional, the context package_line
        :return: A dictionary containing the following key :

            - 'responses':
                list of dictionary {
                  'response': response,

                  message': message},
            - 'operations':
                list of dictionary {
                  'quantity': quantity or 0,

                  'action': action_id,

                  'activity': activity_id,

                  'time': time,

                  'state': state or 'new' or processed}
            - 'usages':
                list of dictionary  {'quantity': quantity or 0,
                  'is_processed': False,

                  'package_line_ids': package_line_ids,

                  'activity_id': activity_id,

                  'usage_date': time,

                  'operation_id': operations,

                  'mode': mode, or None,},
            - 'messages':
                list of string or None,
        """
        self.ensure_one()
        self.clear_result()

        # Verify parameters
        trigger, trigger_type = self.get_trigger()
        if not action:
            raise AttributeError("The attribute 'action' is required")
        if not isinstance(action, models.Model):
            raise TypeError("The attribute 'action' must be a record")
        action.ensure_one()
        if not trigger:
            raise AttributeError("The attribute 'trigger' is required")
        if not isinstance(trigger, models.Model):
            raise TypeError("The attribute 'trigger' must be a record")
        if trigger._name not in ['device.query', 'horanet.operation']:
            raise TypeError("The rule must have a query or an operation as trigger")

        if force_time and isinstance(force_time, str):
            force_time = fields.Datetime.from_string(force_time)
        elif force_time and not isinstance(force_time, (datetime.datetime, datetime.date)):
            raise AttributeError("The argument 'force_time' must be a datetime object")
        force_time = force_time or datetime.datetime.now()

        query = False
        operation = False
        if trigger._name == 'device.query':
            query = trigger
        else:
            operation = trigger

        self._execution_context = {'activity': activity or None,
                                   'action': action or None,
                                   'time': force_time or None,
                                   'package_ids': package_ids or None}

        # TODO use decorator to avoid breaking demeter law (global var)
        def disabled_method(self, *args, **kwargs):
            raise UserError("Not permitted during code evaluation")

        # result = self.env['activity.rule.execution.result'].create_execution_result(
        #     rule=rule, activities=activity, trigger=trigger, time=force_time,
        #  package_lines=package_ids, action=action)

        # new_cr = self.pool.cursor()
        # new_cr.commit = types.MethodType(disabled_method, self)

        try:
            # TODO : try to improve security with save point before rule execution and monkey patch on critical method
            global_context = self.get_standard_rule_context(default_activity=activity, default_action=action,
                                                            default_package_ids=package_ids, default_time=force_time)
            # TODO: voir si ajouter le prefetch de l'environement courant à l'environement de test accélère l'exécution

            with hgo_utils.safe_environment(self.with_context({'force_time': force_time}).env) as safe_env:
                # Permet d'éviter de devoir expliquer la différence entre None et Empty aux CP
                package_ids = package_ids or safe_env['horanet.package']
                eval_local = {'env': safe_env,
                              'action': action.read(),
                              'RULE': rule.with_env(safe_env),
                              'QUERY': self.swap_environment(query, safe_env),
                              'OPERATION': self.swap_environment(operation, safe_env),
                              'activity': self.swap_environment(activity, safe_env),
                              'contractlines': self.swap_environment(package_ids, safe_env),
                              }
                # eval_local.update({'self': env['activity.rule'].browse([self.id])})
                # Ajout des local dans le dictionnaire global le temps de trouver une solution, voir :
                # TODO : trouver un moyen de passer les locals au wrapper de méthode ou modifier les optcode interdits
                global_context.update(eval_local)
                safe_eval(rule.embedded_rule_code,
                          global_context,
                          eval_local,
                          mode='exec',
                          nocopy=True)
        except Exception as e:
            _logger.debug(e)
            # add decode pour formatter les messages d'exception avec '\\n' (.decode('string_escape'))
            # TODO : override safe_eval to provide better exception (without the code embedded for exemple)
            raise

        self._validate_execution_result()

        rule_log = [self.cast_unicode(log) for log in self.__log__]

        for response in self.__responses__:
            response['message'] = self.cast_unicode(response.get('message', ''))

        # Remove the safe_environment of the resulting objects (in each values of the dictionary of the list) ...
        self.__responses__ = [dict([(kv[0], self.swap_environment(kv[1], self.env)) for kv in iter(list(rep.items()))])
                              for rep in self.__responses__]
        self.__operations__ = [dict([(kv[0], self.swap_environment(kv[1], self.env)) for kv in iter(list(ope.items()))])
                               for ope in self.__operations__]
        self.__usages__ = [dict([(kv[0], self.swap_environment(kv[1], self.env)) for kv in iter(list(usage.items()))])
                           for usage in self.__usages__]
        self.execution_result = {
            'responses': self.__responses__ or None,
            'operations': self.__operations__ or None,
            'usages': self.__usages__ or None,
            'messages': rule_log or None,
        }

        return self.execution_result

    def get_trigger(self):
        """Get the trigger associated with this rule execution.

        :return: Return the trigger if it exists and it's type ('query' or 'operation')
            in a tuple (trigger_record, string type)
        """
        if not self.trigger_id:
            raise AttributeError("trigger_id is mandatory")
        elif self.trigger_id._name == 'device.query':
            return self.trigger_id, TRIGGER_TYPE_QUERY
        else:
            return self.trigger_id, TRIGGER_TYPE_OPERATION

    def _validate_execution_result(self):  # noqa: C901
        """Try to resolve the relational values of the rule execution result.

        This method should be called outside the execution environment, to avoid record mismatch during resolution,
        if a record is created in the execution environment, it will not persist outside.
        """
        # Tout les attributs non relationnel doivent déjà avoir été validés (int, string, date, etc..)
        def _resolve_action(action, default_action):
            action_rec = action or default_action
            if not action_rec:
                raise ValueError("The argument 'action' is required")
            if action_rec and isinstance(action_rec, int):
                action_rec = self.env['horanet.action'].browse(action_rec)
                if not action_rec:
                    raise ValueError("Action not found. The action id '{action_id}' does not exist".format(
                        action_id=str(action_rec)))
            if action_rec and isinstance(action_rec, str):
                action_rec = self.env['horanet.action'].search([('code', '=ilike', action_rec)])
                if not action_rec:
                    raise ValueError("Action not found. The action code '{action_code}' does not exist".format(
                        action_id=str(action_rec)))
            if not isinstance(action_rec, models.Model) or action_rec._name != 'horanet.action':
                raise ValueError("The argument 'action' should be an 'horanet.action' record")
            return action_rec

        def _resolve_activity(activity, default_activity):
            activity_rec = activity or default_activity
            if not activity_rec:
                if self._execution_context.get('activity', False):
                    activity_rec = self._execution_context['activity']
                else:
                    raise ValueError("The argument 'activity' is required")
            if activity_rec and isinstance(activity_rec, int):
                activity_rec = self.env['horanet.activity'].browse(activity_rec)
                if not activity_rec:
                    raise ValueError("Activity not found. The activity id '{activity_id}' does not exist".format(
                        action_id=str(activity_rec)))
            if activity_rec and isinstance(activity_rec, str):
                activity_rec = self.env['horanet.activity'].search([('reference', '=ilike', activity_rec)])
                if not activity_rec:
                    raise ValueError("Activity not found. The activity code '{activity_code}' does not exist".format(
                        action_id=str(activity_rec)))
            if not isinstance(activity_rec, models.Model) or activity_rec._name != 'horanet.activity':
                raise ValueError("The argument 'activity' should be an 'horanet.activity' record")
            return activity_rec

        # Validation des relation des opérations
        for operation in self.__operations__:
            # Resolve action
            operation['action_rec'] = _resolve_action(
                operation.get('action_rec', False),
                self._execution_context.get('action', False))
            # resolve activity
            operation['activity_rec'] = _resolve_activity(
                operation.get('activity_rec', False),
                self._execution_context.get('activity', False))

        for usage in self.__usages__:
            usage['activity_rec'] = _resolve_activity(
                usage.get('activity_rec', False),
                self._execution_context.get('activity', False))

    @staticmethod
    def cast_unicode(string):
        """Convert a string of unknown origine to unicode.

        :param string: The string to convert
        :return: an unicode string
        """
        if isinstance(string, str):  # nothing to do if type unicode
            try:
                string = string.decode('ascii')
            except UnicodeDecodeError:
                string = string.decode('utf-8')
        return string

    @staticmethod
    def _rule_response(list_response, response, message=None, final=False, technical_string=False):
        if not isinstance(response, bool):
            raise TypeError("The argument 'response' must be an boolean not a {bad_type}".format(
                bad_type=str(type(response))))
        if message and not isinstance(message, str):
            raise TypeError("The argument 'message' must be a string not a {bad_type}".format(
                bad_type=str(type(message))))
        if technical_string and not isinstance(technical_string, str):
            raise TypeError("The argument 'technical_string' must be a string not a {bad_type}".format(
                bad_type=str(type(technical_string))))
        if not isinstance(final, bool):
            raise TypeError("The argument 'final' must be an boolean not a {bad_type}".format(
                bad_type=str(type(final))))

        list_response.append({'response': response, 'message': message,
                              'final': final, 'technical_string': technical_string})
        return True

    @staticmethod
    def _rule_operation(list_operation, quantity, action, activity=None, time=None, compute=True):
        if not isinstance(quantity, (int, float)):
            raise TypeError("The argument 'quantity' must be an integer or a float not a {bad_type}".format(
                bad_type=str(type(quantity))))

        list_operation.append({
            'quantity': quantity or 0,
            'action_rec': action,
            'activity_rec': activity,
            'time': time,
            'disable_computation': compute
        })

    @staticmethod
    def _rule_usage(list_usage, quantity, activity, packages=None, mode=None, time=None, operations=None):
        if not isinstance(quantity, (int, float)):
            raise Exception("The usage quantity must be an integer")

        if not mode:
            mode = 'expire'
        if not isinstance(mode, str):
            raise Exception("The mode must be a string. Ex ('free','expire')")

        if mode not in ['free', 'expire']:
            raise ValueError("The mode must be a string. Ex ('free','expire')")

        # activity_id = activity
        # if activity and isinstance(activity, models.Model):
        #     activity.ensure_one()
        #     activity_id = activity.id

        if isinstance(packages, models.Model):
            package_ids = packages.ids
        else:
            package_ids = packages

        list_usage.append({
            'quantity': quantity or 0,
            'is_processed': False,
            'package_ids': package_ids,
            'activity_rec': activity,
            'usage_date': time,
            'operation_id': operations,
            'mode': mode,
        })

    @staticmethod
    def _log(full_log, message):
        full_log.append(message)

    def get_standard_rule_context(self, default_activity, default_action, default_package_ids, default_time):
        """Get the rule execution context (globals usable during computation).

        Attention : never use self or record object in context (as they are not safe for eval)
        :return: context dictionary
        """
        execution_context = dict()
        self.__responses__ = list()
        self.__operations__ = list()
        self.__usages__ = list()
        self.__log__ = list()

        execution_context.update({
            'datetime': datetime,
            'timedelta': datetime.timedelta,
            'response': partial(self._rule_response, self.__responses__),
            'operation': partial(self._rule_operation, self.__operations__),
            'usage': partial(self._rule_usage, self.__usages__),
            'log': partial(self._log, self.__log__),
        })

        return execution_context

    @api.model  # noqa: C901 - Complexité à 21
    def create_new_result(self):
        # TODO : check run_result arg
        trigger, trigger_type = self.get_trigger()
        if not self._execution_context:
            raise Exception("Must compute before creating a result")
        exec_context = self._execution_context
        exploitation_result = self.env['exploitation.engine.result'].new({'trigger': trigger})
        self._validate_execution_result()

        # création des opérations résultante de l'éxécution
        if self.__operations__:
            for operation in self.__operations__:
                operation_action_rec = operation['action_rec']
                operation_activity_rec = operation['activity_rec']
                vals = {
                    'action_id':
                        operation_action_rec and operation_action_rec.id
                        or trigger.action_id and trigger.action_id.id,
                    'quantity':
                        operation.get('quantity', 0.0),
                    'origin_engine_result_id':
                        exploitation_result,
                    'number':
                        trigger_type == TRIGGER_TYPE_OPERATION and trigger.number or '',
                    'tag_id':
                        trigger.tag_id and trigger.tag_id.id,
                    'device_id':
                        trigger.device_id and trigger.device_id.id or False,
                    'check_point_id':
                        trigger.check_point_id and trigger.check_point_id.id or False,
                    'activity_id':
                        operation_activity_rec and operation_activity_rec.id
                        or trigger.activity_id and trigger.activity_id.id,
                    'time':
                        operation.get('time', False)
                        or exec_context.get('time', False)
                        or trigger_type == TRIGGER_TYPE_OPERATION and trigger.time
                        or trigger.write_date,
                    'disable_computation':
                        operation.get('disable_computation', False),
                }
                exploitation_result.operation_ids += exploitation_result.operation_ids.new(vals)

        # Création de réponses (seulement si le trigger est une query)
        if trigger_type == TRIGGER_TYPE_QUERY and self.__responses__:
            exploitation_result.trigger_query_id = trigger
            new_reponse = self.env['device.response'].sudo().new({
                'origin_engine_result_id': exploitation_result,
                'response': self.__responses__[0]['response'],
                'message': self.__responses__[0].get('message', ''),
            })
            exploitation_result.response_id = new_reponse

        # Création des usages (seulement si le trigger est une opération)
        if trigger_type == TRIGGER_TYPE_OPERATION and self.__usages__:
            # TODO:
            # Création d'une variable de stockage de relation package_line/quantity pour stocker l'évolution virtuel de
            # la quantité au fur et à mesure de la création des usages
            # all_package_lines = set([u['package_line_ids'] for u in self.__usages__])
            # all_package_lines += exec_context.get('package_lines', [])
            # tmp_quantity_by_package_line = dict([(pack, pack.quantity) for pack in all_package_lines])

            for usage in self.__usages__:
                usage_activity_rec = usage['activity_rec']
                quantity = usage['quantity']
                vals = {
                    'quantity': 0,
                    'is_processed': False,
                    'package_line_id': False,
                    'activity_id':
                        usage_activity_rec and usage_activity_rec.id
                        or trigger.activity_id and trigger.activity_id.id,
                    'usage_date':
                        usage.get('time', False)
                        or exec_context.get('time', False)
                        or trigger.time,
                    'operation_id':
                        usage.get('operations', trigger.id or False),
                    'origin_engine_result_id':
                        exploitation_result,
                }

                conso = []
                package_ids = usage.get('package_ids', False) or exec_context.get('package_ids')
                if isinstance(package_ids, (list, tuple, str, int)):
                    package_ids = self.env['horanet.package'].sudo().browse(package_ids)
                package_line_ids = package_ids.get_active_line(vals.get('usage_date'))
                if package_line_ids:
                    mode = usage.get('mode', False)
                    if mode not in ['free', 'expire']:
                        raise NotImplemented("Mode must be set as 'free' or 'expire'")
                    else:
                        # Faire un double "order by" sur les périodes de forfait, soit
                        # free --> free (puis expire si plusieurs gratuit)
                        # expire --> date de fin, puis gratuit en cas de dates égales
                        if mode == 'free':
                            sorted_pl = package_line_ids.sorted(
                                key=lambda pl: pl.closing_date).sorted(
                                key=lambda pl: pl.is_salable)
                        else:
                            sorted_pl = package_line_ids.sorted(
                                key=lambda pl: pl.is_salable).sorted(
                                key=lambda pl: pl.closing_date)

                        for pl in sorted_pl:
                            if quantity <= 0:
                                break
                            if pl.can_use(quantity):
                                tmp = dict(vals)
                                tmp.update({'package_line_id': pl.id,
                                            'quantity': quantity})
                                quantity = 0
                                conso.append(tmp)
                                break
                            elif pl.get_balance() > 0:
                                tmp = dict(vals)
                                quantity = quantity - pl.get_balance()
                                tmp.update({'package_line_id': pl.id,
                                            'quantity': pl.get_balance()})
                                conso.append(tmp)
                if quantity > 0 or not package_line_ids:
                    # Si plus ou pas de forfait à débiter, les consos seront flottantes
                    tmp = dict(vals)
                    tmp.update({'package_line_id': False,
                                'quantity': quantity})
                    conso.append(tmp)

                for new_conso in conso:
                    exploitation_result.usage_ids += self.env['horanet.usage'].new(new_conso)

        return exploitation_result

    @staticmethod
    def swap_environment(record, environment):
        """Modifie l'environment d'un record d'ORM.

        Essaie de substituer l'environement d'un recordset, si l'objet 'record' est un model de l'ORM

        :param record: record d'ORM ou n'importe quel objet python
        :param environment: L'environment à substituer
        :return: Le record avec le nouvel environnement, (si recordset) sinon, l'objet de base
        """
        if record and isinstance(record, models.Model):
            if not record.ids and isinstance(record.id, models.NewId):
                # dans le cas d'un nouvel objet n'existant que dans le cache
                return environment[record._name].new(hgo_utils.get_record_values(record))

            # Copie du cache de l'enregistrement à copier dans l'environment de destination, afin de prendre en
            # compte le cas ou le record a copier n'existe pas encore en base (et n'est pas un new_ID).
            # C'est par exemple le cas d'un record précédemment crée dans la
            # transaction courante (voir api HDCOM query)close_ftp_connection
            fields.copy_cache(record, environment)

            return record.with_env(environment)
        return record

    # endregion
    pass
